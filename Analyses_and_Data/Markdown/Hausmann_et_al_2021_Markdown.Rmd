---
title: "Light environment influences mating behaviours during the early stages of divergence in tropical butterflies"
author: "Alexander E. Hausmann"
date: "last edited: `r format(Sys.time(), '%d %B %Y')`"
output: 
  pdf_document:
    number_sections: true
    toc_depth: 4
    df_print: paged

#Prettier in HTML, but HTML files often are not accepted for supplementary material:
  #rmdformats::readthedown:
    #number_sections: true
    #toc_depth: 4
    #df_print: paged

extra_dependencies: ["xcolor","formatR"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = 'C:/Users/Hausmann/Desktop/visual_preference_heurippa_linaresi/Analyses_and_Data/')
```
```{r, include=FALSE}
library(knitr)
library(rmdformats)
opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=TRUE)
```

**Authors**: Alexander E. Hausmann, Chi-Yun Kuo, Mar√≠lia Freire, Nicol Rueda-M, Mauricio Linares, Carolina Pardo-Diaz, Camilo Salazar, Richard M. Merrill

**Published in**: Proceedings of the Royal Society B (2021)

**DOI**: doi:10.1098/rspb.2021-0157


# Initial explantions and setup

**Note**: the order of the analyses in this Markdown does not always follow the order of the Results section from the manuscript.

**Note**: *Heliconius heurippa* will be abreviated with '*heu*', *Heliconius timareta linaresi* with '*lin*'

**Note**: even though we differentiated between 'approaches', 'courtship initiation' and 'sitting on mounted female' during scoring of the video material, we unite these three behaviours here as 'interactions' and analyse them as one variable. All three types of behaviours always include an approach of the male, which means that we are basically only looking at approaches in this analysis. All three behaviours were correlated within types and uniting them increases our power to detect differences.

**Note**: if we speak of preference values in the following, these refer to the proportion of interactions males perform towards the *heu* 'female' (a preference score of 0 indicates that all interactions were performed towards the *lin* 'female', a value of 1 indicates that all interactions were performed towards the *heu* 'female', a value of 0.5 indicates that there was equally many interactions with each type of 'female').

**Note**: to a point estimate for posterior distributions, we will use (unconventionally) the **mean** here (not the median, as most people do). The reason for that is that we will perform a lot of "posterior calculus" below. For example, for the Gardner-Altman plots below, we will plot the estimators of two groups, say A and B, as well as the estimator for the difference between these two groups. Now, median(B)-median(A) does most likely not equal median(B-A). But mean(B)-mean(A) equals mean(B-A). Therefore, for all point estimators to add up to values that make sense as a whole, we have to use the mean. To describe the 95% credible interval (CrI), we will use (as quite common), the 95% equal-tailed interval. Alternatively, one could use the high density interval.

Memorize GitHub directory, repository, and folder.
```{r}
github<-"https://raw.githubusercontent.com"
repos<-"/SpeciationBehaviour/visual_preference_heurippa_linaresi"
folder<-"/master/Analyses_and_Data/Skripts_called_from_Markdown"
```

Call `plot_proportion_stats.R`{.R}, which contains a function that will later be used for producing the stripchart graphs. We outsourced this function to GitHub to make this Markdown more concise.
```{r}
source(paste0(github,repos,folder,"/Plot_Proportion_Stats.R"))
```

Call `other_plot_functions.R`{.R} which contains functions that will be used below for plotting and which are saved in a separate script, again, to make this Mardown more concise.
```{r}
source(paste0(github,repos,folder,"/other_plot_functions.R"))
```

To be safe, we set a seed here (but all functions requiring a random number generator should have a seed set within the function).

Note that if you use an R version < 3.6 you may not be able to reproduce our exact results on your computer since R implemented a new mechanism for random number generation and set it as the new default. But this new option is not available in older versions.
```{r}
set.seed(42)
```

Load/install libraries

For Bayesian regression models (using 'Stan')
```{r}
if(!"brms"%in% rownames(installed.packages())){
  install.packages("brms")
}
suppressMessages(suppressWarnings(library(brms)))
```

Note that for `brms`{.R} to work, you need to have a C++ compiler (which can be the R internal `Rtools`{.R}) as well as the R library `rstan`{.R} installed. Both may be installed automatically if you install `brms`{.R}. We ran analyses on a Windows machine and had to re-install `rstan`{.R}, since otherwise some models crashed. Use the following code if you're on Windows:

`install.packages("rstan", type = "win.binary", dependencies = TRUE)`{.R}

For glmer
```{r}
if(!"lme4"%in% rownames(installed.packages())){
  install.packages("lme4")
}
suppressMessages(suppressWarnings(library(lme4)))
```

For estimated marginal means and contrasts between different factors.
```{r}
if(!"emmeans"%in% rownames(installed.packages())){
  install.packages("emmeans")
}
suppressMessages(suppressWarnings(library(emmeans)))
```

For weighted histograms
```{r}
if(!"weights"%in% rownames(installed.packages())){
  install.packages("weights")
}
suppressMessages(suppressWarnings(library(weights)))
```

For converting PDF to PNG
```{r}
if(!"pdftools"%in% rownames(installed.packages())){
  install.packages("pdftools")
}
suppressMessages(suppressWarnings(library(pdftools)))
```

For reading in PNGs
```{r}
if(!"png"%in% rownames(installed.packages())){
  install.packages("png")
}
suppressMessages(suppressWarnings(library(png)))
```

For displaying PNGs
```{r}
if(!"grid"%in% rownames(installed.packages())){
  install.packages("grid")
}
suppressMessages(suppressWarnings(library(grid)))
```

For weighted 2-D Kernel densities we need `ggtern`{.R}.
```{r}
if(!"ggtern"%in% rownames(installed.packages())){
    install.packages("ggtern")
}
suppressMessages(suppressWarnings(library(ggtern)))
```

`MASS`{.R} is used for (unweighted) Kernel densitites.
```{r}
if(!"MASS"%in% rownames(installed.packages())){
    install.packages("MASS")
}
suppressMessages(suppressWarnings(library(MASS)))
```

`beeswarm`{.R} is used for regular beeswarm plots.
```{r}
if(!"beeswarm"%in% rownames(installed.packages())){
    install.packages("beeswarm")
}
suppressMessages(suppressWarnings(library(beeswarm)))
```

# Choice experiment with *heu* and *lin* mounted females

## Data Read-in & Exploration

### Read in data

Keep all strings as characters and change the relevant columns to factors later.
```{r}
pref_stat<-read.csv("Data/mounted_female_data.csv",header=T,stringsAsFactors = F)
```

One row of the table represents one single interaction between a male and a mounted female.

The columns indicate:

* **court_lin_heu_01** = *0*: Interaction of male with *lin* 'female', *1*: Interaction with *heu* 'female' 
* **behaviour** = Type of interaction with 'female'; *approach*: approach, *court_init*: approach + courtship initiation, *sitting*: approach + courtship initiation + sitting on 'female'
* **ID** = Individual identifier
* **type** = *HC*: *heu*, *TLC*: *lin*, *TLCxHC*: F1 with *lin* mother and *heu* father (this type was used to produce backcrosses), *HCxTLC*: F1 with *heu* mother and *lin* father,
*(TLCxHC)xTLC*: (female-informative) backcross to *lin* with F1 mother, *TLCx(TLCxHC)*: (male-informative) backcross to *lin* with F1 father, *HCx(TLCxHC)*: (male-informative) backcross to *heu* with F1 father
* **redYN** = Whether male has red on wings (*Y*) or not (*N*)
* **date** = Date in yyyy_mm_dd
* **trial** = Trial of the day
* **time_of_day** = Time of day in seconds
* **age_male** = Age of male
* **HC_model_ID** = ID of *heu* 'female'
* **TLC_model_ID** = ID of *lin* 'female'
* **position_HC** = Recording position of *heu* 'female' in cage
* **position_TLC** = Recording position of *lin* 'female' in cage
* **light_HC** = lux intensity at *heu* 'female'
* **light_TLC** = lux intensity at *lin* 'female'
* **grayscale_mean_at_visited** = a representative frame of each interaction between a male and a mounted female was transferred to grayscale using the `imager`{.R} package. The grayscale is determined via a linear approximation to luminance. A value of a pixel in grayscale ranges from 0 (black) to 1 (white). This column shows the mean pixel value.
* **light_class_HC** = for each interaction of a *lin* or *heu* individual with either mounted female, we scored the light environment at the *heu* model from the video footage. We defined three classes of light environment: "sunny" (mounted female in sun), "cloudy" (mounted female in shade; most likely overcast conditions) or "sunny_but_treeshade" (mounted female in shade created by vegetation; sunny patches can be seen away from the mounted female). While the first two environments would speak for a flat irradiance curve (i.e. light arriving at the mounted female is uniformly distributed across wavelengths), the third would speak for more blueish light coming from the blue sky (less light from the red spectrum). Because we didn't store the raw video files, the light at the *heu* mounted female had to be reconstructed for datapoints where the *lin* female was visited. We seeked the closest frame from our remaining video footage of the *heu* mounted female. If the closest frame was >10 minutes away from the disired time point, an `NA`{.R} was entered.
* **temp** = Temperature
* **hum** = Humidity
* **observer** = Observer ID
* **broods** = Stock individuals (pure species) indicated with *Stock* in beginning. Equal identifiers may indicate that males are brothers (if born around the same date), but may also not. Hybrid cross IDs always start with *C1...*; males with same cross ID are always brothers. 
* **HC_type** = Only of relevance for *heu* males. *Old_Stock* are males from the first *heu* stock we used, which was created from populations from Lejanias, Buenavista and Santa Maria. *SM-Stock* males come from a stock which exclusively traces back to the population from Santa Maria.
* **exp_line** = Only of relevance for *lin*-*heu* hybrids. Gives their affiliation with a certain F1 cross which were each used to generate multiple backcrosses. E.g. TLCx(TLCxHC) males may be of different broods, but from the same experimental line. This means they trace back to the same F1 cross and had therefore the same *heu* grandfather. Note that line_3 males do not result from the same F1 cross, but have the same *heu* grandfather (who mated two *lin* females).
* **males_inside** = Number of males in cage during day of experiment.
* **resp_other_males** = Number of interactions that other males showed with either 'female' in the trial during which data point was generated
* **pref_other_males** = Preference of other males in the trial during which data point was generated.


Discard immature male data (we assume only males of an age of 5+ days will be sexually mature (and therefore show preferences)).
```{r}
pref_stat<-pref_stat[pref_stat$age_male>4,]
```


### Correlation of individual preferences during a trial with preference of other males

We first want to get a brief idea of how preference of individual males during a trial correlates with preference of all other males during that trial (mind though correlation vs. causation!). 

**Note**: our data sheet does not contain all data from all males that were flying through our cage during experiments (we excluded data from a few males from types that play no role for this publication to keep the data sheet more understandable). The column `pref_other_males`{.R} was though calculated including those males into the calculations (and therefore shows the "correct" preference of all other males present).

We fit some easy generalized linear mixed-effects models with `glmer`{.R}. To just get a quick idea of the correlations, we predict the probabilities of a male to respond to the *heu* 'female' by setting preference of other males either to 0, 0.5 or 1. We first do this for all males appearing in the experiment and then look at the different types separately. Individual ID is set as random effect.
```{r}
#Run model for all males
all_corr<-glmer(court_lin_heu_01~pref_other_males+(1|ID),family=binomial,data=pref_stat)
#Predict preference of individual while preference of other males is at 0, 0.5 or 1.
pred_all_corr<-as.numeric(predict(all_corr,data.frame(pref_other_males=c(0,0.5,1)),type="response",re.form=NA))
#Create data frame which will be filled with additional information on all the types later
corr_data<-data.frame(type="ALL",predict_0=round(pred_all_corr[1],2),predict_0.5=round(pred_all_corr[2],2),predict_1=round(pred_all_corr[3],2),stringsAsFactors=F,row.names=c())
#Get all unique types
unique_types<-sort(unique(pref_stat$type))
#Run through all types
for(typo in 1:length(unique_types)){
  #Run the model for the current type
  sub_corr<-glmer(court_lin_heu_01~pref_other_males+(1|ID),family=binomial,data=pref_stat[pref_stat$type==unique_types[typo],])
  pred_sub_corr<-as.numeric(predict(sub_corr,data.frame(pref_other_males=c(0,0.5,1)),type="response",re.form=NA))
  #Append to data frame
  corr_data<-rbind(corr_data,c(unique_types[typo],round(pred_sub_corr,2)))
}
#Show results
print(corr_data)
```

We can see that the higher the preference for the *heu* 'female' of other males during a trial, the more likely it is that an individual interacts with the *heu* 'female', throughout all types of males. This may be due to:

* Light conditions differing at the two recording stations (which may not only affect male choice, but also whether our program detected movement or not) 
* Certain recording stations being more attractive because of other reasons (e.g. because of closer proximity to food)
* One of the 'females' being specifically attractive/unattractive during a recording day
* Learning of individuals from other individuals 

While the first three would speak for mere correlation between behaviour of the butterflies in our cage, the latter would speak for causation in a sense that individuals learn from each other. We decided not to include preference of other males during a trial in our models later on, since we cannot really correct for number of responses of other males (e.g. a preference score for other males coming from one observation during a trial results in a skewed preference of 0 or 1 and this will get the same weight as a score coming from many observations); this is also why the presented table above has to be interpreted with CAUTION. 

We also avoided including recording position in the cage of the two mounted females during a trial as random effect in our models (e.g. `(1|position_HC) + (1|position_TLC) + (1|position_HC:position_TLC)`{.R}). Variance explained by cage positions is tighly linked with illuminance differences since certain positions always were more prone to exposure to sun illuminance than others. Since conditions around the recording positions also changed immensly over the course of the experiment, including it as a "static" factor seemed to be questionable.

To avoid overcomplication of the model, we also did not include 'mounted female model'-IDs into our statistical model (with e.g. `(1|HC_model_ID) + (1|HC_model_ID) + (1|HC_model_ID:TLC_model_ID)`{.R}). Both variables contained a large amount of factors and added little improvement to model fit. Also, same as for the recording positions, attractiveness of 'females' may have changed over the course of their use, which is why including them as "static" factors also would bear problems.

We did attempt correcting for all the variance caused by all these different effects by including trial (and date) as random effects in the models (see below). This should cover the majority of differences in recording positions and 'female' attractiveness.


### Potential for collinearity between the illuminance measures

Since our mounted females were always set up in relatively close proximity to each other, we expect the two illuminance measurements to be correlated.
Assuming logarithmic perception of illuminance in Heliconius (see more detailed explanation later), we plot the "log-illuminance" at the *heu* 'female' (`log10`{.R} of *heu* lux measurement) against the "log-illuminance" at the *lin* 'female' (`log10`{.R} of *lin* lux measurement).
```{r,fig.width=6, fig.height=6}
par(mar=c(4,4,0.3,0))
plot(log10(pref_stat$light_HC),log10(pref_stat$light_TLC),pch=20,col=adjustcolor("black",0.03))
```

We see that those two are quite correlated. If we look at the correlation coefficient and the ${R^2}$ value, we can see that they do show some degree of correlation, which is though not enough to be worried about including both measurements into the same model.
```{r}
cor(log10(pref_stat$light_HC),log10(pref_stat$light_TLC),use = "pairwise.complete.obs")
summary(lm(log10(pref_stat$light_HC)~log10(pref_stat$light_TLC)))$r.squared
```

### Adding new columns

In short, lux is a measurement of the amount of photons hitting a surface per time. We assume that perception of illuminance in *Heliconius*, as in humans, is logarithmically scaled, i.e. a change from 100 and 1'000 lux (illuminance) would be perceived as much of a change as going from 1'000 to 10'000 lux (such 'logarithmic perception of illuminance' has been shown in in the fly, see Laughlin, Simon B. "Matching coding, circuits, cells, and molecules to signals: general principles of retinal design in the fly's eye." Progress in retinal and eye research 13.1 (1994): 165-196.). The exact formula for defining 'lighting steps' (i.e. whether e.g. 1000 lux would be perceived twice or thrice as bright as 100 lux) is hard to predict for *Heliconius* butterflies. 

To calculate the log-illuminance score at each 'female' we take the logarithm to the base 10 of each illumance measurement. 
```{r}
pref_stat$log_light_HC<-log10(pref_stat$light_HC)
pref_stat$log_light_TLC<-log10(pref_stat$light_TLC)
```

We quickly compare our total recorded log-illuminance values to the log-illuminance values when the males actually responded. For this we will load two big txt files containing illuminance measures at the two 'females' at every second of the experiment. These data will only be used for this (not so relevant) following exploratory graph (and most likely we won't provide these online, since file size is so big).

Read in illuminance data for all seconds of the experiment.
```{r}
lux_heu<-read.table("Data/Light_heurippa.txt",
                    header=T,stringsAsFactors = F)
lux_lin<-read.table("Data/Light_linaresi.txt",
                    header=T,stringsAsFactors = F)
```

Calculate range of log-illuminance values.
```{r}
range_all<-range(c(log10(lux_heu$lux),
                   log10(lux_lin$lux),
                   pref_stat$log_light_HC,
                   pref_stat$log_light_TLC),
                 na.rm = T)
```

Generate histograms for the total recorded log-illuminance values at the *heu* 'female' as well as the log-illuminance values at the *heu* 'female' when responses occured at this 'female'. The histograms for the the total recorded log-illuminance are weighted by number of individual males present in the cage at each respective day.
Do the same for the *lin* 'female'.
```{r}
hist_heu_light<-wtd.hist(log10(lux_heu$lux),weight=lux_heu$males_5d,plot=F,
                             breaks=seq(range_all[1],range_all[2],length.out=30))
hist_lin_light<-wtd.hist(log10(lux_lin$lux),weight=lux_lin$males_5d,plot=F,
                             breaks=seq(range_all[1],range_all[2],length.out=30))

hist_heu_resp<-hist(log10(pref_stat$light_HC[pref_stat$court_lin_heu_01==1]),plot=F,
                    breaks=seq(range_all[1],range_all[2],length.out=30))
hist_lin_resp<-hist(log10(pref_stat$light_TLC[pref_stat$court_lin_heu_01==0]),plot=F,
                    breaks=seq(range_all[1],range_all[2],length.out=30))
```

Scale the histograms to have the same area.
```{r}
heu_resc<-(sum(hist_heu_light$counts)/sum(hist_heu_resp$counts))
lin_resc<-(sum(hist_lin_light$counts)/sum(hist_lin_resp$counts))
hist_heu_resp$counts<-hist_heu_resp$counts*heu_resc
hist_lin_resp$counts<-hist_lin_resp$counts*lin_resc
```

Plot histograms! Black for total recorded, beige for log-illuminance when responses occurred.
```{r}
#Layout setup
layout(matrix(1:2,nrow=1))
par(oma=c(0,0,1,0))
par(mar=c(4.2,0.5,1.5,0.5))

#Add histograms
plot(hist_heu_light,col=adjustcolor("black",0.5),ylab="",xlab="log10 lux",yaxt="n",main=substitute(paste("Mounted ",italic("H. heurippa")," female")))
plot(hist_heu_resp,col=adjustcolor("goldenrod",0.5),add=T)

plot(hist_lin_light,col=adjustcolor("black",0.5),ylab="",xlab="log10 lux",yaxt="n",main=substitute(paste("Mounted ",italic("H. t. linaresi")," female")))
plot(hist_lin_resp,col=adjustcolor("goldenrod",0.5),add=T)

#Add title
mtext("Total Recorded vs. Responses",3,outer=T,line=0)

#Reset layout
layout(1)
```

We can see that the recording density is roughly the same for both 'females' and also the distribution of the responses is similar. At both mounted females, way more responses occurred at bright light conditions (more male activity or higher sensitivity of the motion-detection software).

We also check if the illuminance measurements correlate with the brightness from the camera picture (as measured by the mean Luma-based grayscale score). We plot for the two mounted female types separately log-illuminance vs. the mean grayscale score of the video footage and lay a loess regression +-1.96 SE through it.
```{r}
#x limits
xlims<-range(pref_stat[!is.na(pref_stat$grayscale_mean_at_visited),c("log_light_TLC","log_light_HC")],na.rm = T)
#y limits - we cap at 0.66 to exclude one single outlier datapoint (which was however considered in the loess regression)
ylims<-c(min(pref_stat$grayscale_mean_at_visited,na.rm = T),0.66)

#Fit loess regression to heu data
loess1<-loess(pref_stat$grayscale_mean_at_visited[pref_stat$court_lin_heu_01==1]~pref_stat$log_light_HC[pref_stat$court_lin_heu_01==1],span=0.9)
#Get unique x-values to predict over
uni_x1<-sort(unique(pref_stat$log_light_HC[pref_stat$court_lin_heu_01==1&!is.na(pref_stat$grayscale_mean_at_visited)]))
#Make the prediction
predi1<-predict(loess1,uni_x1,se = T)

#Repeat for lin model
loess2<-loess(pref_stat$grayscale_mean_at_visited[pref_stat$court_lin_heu_01==0]~pref_stat$log_light_HC[pref_stat$court_lin_heu_01==0],span=0.9)
uni_x2<-sort(unique(pref_stat$log_light_HC[pref_stat$court_lin_heu_01==0&!is.na(pref_stat$grayscale_mean_at_visited)]))
predi2<-predict(loess2,uni_x2,se = T)

png("Graphs/for_supplementary_figure1.png",width=3000,height=1500,res=300)
layout(matrix(1:2,ncol=2))
par(mar=c(3,3.5,0.2,0.2))
#Plot illuminance measures at the heu model vs. mean grayscale score of video frame
plot(pref_stat$log_light_HC[pref_stat$court_lin_heu_01==1],
     pref_stat$grayscale_mean_at_visited[pref_stat$court_lin_heu_01==1],
     pch=20,col=adjustcolor("black",0.1),
     xlim=xlims,ylim=ylims,xaxt="n",yaxt="n",xlab="",ylab="")
#Add +-1.96 SE of loess line
polygon(c(uni_x1,rev(uni_x1)),c(predi1$fit-1.96*predi1$se.fit,rev(predi1$fit+1.96*predi1$se.fit)),
        border=NA,col=adjustcolor("dodgerblue",0.25))
#Add loess regression
lines(uni_x1,predi1$fit,col="dodgerblue",lwd=2)
#Add axes and axes titles
axis(1,at=log10(c(1.5,5,15,50,150)*1000),paste0(c(1.5,5,15,50,150),"k"),line=-0.7,lwd=0)
axis(1,at=log10(c(1.5,5,15,50,150)*1000),labels=F,lwd=0,lwd.ticks=1,tck=-0.02)
axis(2,las=2,lwd=0,line=-0.5)
axis(2,labels=F,tck=-0.02)
mtext(substitute(paste("Illuminance at mounted ",italic('H. heurippa')," female [",italic('lux'),"]")),
      1,line=2)
mtext("Mean (Luma-based) grayscale value of frame",
      2,line=2)

#Repeat for lin model
par(mar=c(3,3.5,0.2,0.2))
plot(pref_stat$log_light_HC[pref_stat$court_lin_heu_01==0],
     pref_stat$grayscale_mean_at_visited[pref_stat$court_lin_heu_01==0],
     pch=20,col=adjustcolor("black",0.1),
     xlim=xlims,ylim=ylims,xaxt="n",yaxt="n",xlab="",ylab="")
polygon(c(uni_x2,rev(uni_x2)),c(predi2$fit-1.96*predi2$se.fit,rev(predi2$fit+1.96*predi2$se.fit)),
        border=NA,col=adjustcolor("dodgerblue",0.25))
lines(uni_x2,predi2$fit,col="dodgerblue",lwd=2)
axis(1,at=log10(c(1.5,5,15,50,150)*1000),paste0(c(1.5,5,15,50,150),"k"),line=-0.7,lwd=0)
axis(1,at=log10(c(1.5,5,15,50,150)*1000),labels=F,lwd=0,lwd.ticks=1,tck=-0.02)
axis(2,las=2,lwd=0,line=-0.5)
axis(2,labels=F,tck=-0.02)
mtext(substitute(paste("Illuminance at mounted ",italic('H. t. linaresi')," female [",italic('lux'),"]")),
      1,line=2)
mtext("Mean (Luma-based) grayscale value of frame",
      2,line=2)

invisible(dev.off())
```

Show png we just made
```{r}
fig2<-readPNG("Graphs/for_supplementary_figure1.png")
grid.raster(fig2)
```

Pretty strong correlation. The slightly off part at low x-axis values is likely due to mistakes during measrements (e.g. logger fell to the floor or wasn't put up properly). The slight decrease in slope is likely due to the logger being sensitive for IR wavelengths, which are not recorded by the camera.

Finally, we add a new column to the dataset where we concatenate date and trial (to get an ID for each unique trial)
```{r}
pref_stat$date_trial<-paste0(pref_stat$date,"_",pref_stat$trial)
```

### Subsetting and Scaling

We create one new subset table for the *lin*/*heu* dataset and the backcross dataset. 
```{r}
pref_stat_TLC_HC<-pref_stat[pref_stat$type%in%c("TLC","HC"),]
pref_stat_BC<-pref_stat[pref_stat$type%in%c("TLCx(TLCxHC)","(TLCxHC)xTLC"),]
```


## Preference of *H. t. linaresi*, *H. heurippa* and backcross-to-*H. t. linaresi* hybrids and the effect of illuminance at the mounted *H. heurippa* female

### Modelling, Posteriors and CrIs

Define vector of column names involved in models that should become factors and make those columns factors in the three tables.
```{r}
make_fact<-c("type","redYN","ID","broods","exp_line","date","trial","date_trial","observer")
for(change_fact in 1:length(make_fact)){
  pref_stat_TLC_HC[,make_fact[change_fact]]<-as.factor(pref_stat_TLC_HC[,make_fact[change_fact]])
  pref_stat_BC[,make_fact[change_fact]]<-as.factor(pref_stat_BC[,make_fact[change_fact]])
}
```

The full (initial) model encompasses the following fixed effects:

1) **type** (which (species) type a male belongs to) *OR* **redYN** (=genotype around _optix_, i.e. whether a backcross-to-*lin* hybrid has or has not red on its wings)
2) **log_light_HC** (the log-illuminance at the *heu* 'female')
3) **log_light_TLC** (the log-illuminance at the *lin* 'female')
4) The **interaction** between 1) and 2)
5) The **interaction** between 1) and 3)
6) The **interaction** between 2) and 3)
7) The **interaction** between 1), 2) and 3)

Of particular interest are those fixed effects which involve **type** or **redYN** (1, 4, 5, 7).

As random effects, we decide for the following possible options:

1) **ID**: necessary to prevent pseudo-replication/overdispersion.
2) **date** and/or (nested) **date_trial**: this also allows to control for pseudo-replication during experimental units, within dates/trials (e.g. Chamberlain, Nicola L., et al. "Polymorphic butterfly reveals the missing link in ecological speciation." Science 326.5954 (2009): 847-850. included trial as random effect). We use the column **date_trial** as a unique trial identifier (since trial IDs repeat over days).
3) **observer**: control for the person that scored a data point from video material.
4) **exp_line** (only for models involving hybrids): experimental line a hybrid belongs to, i.e. from which F1 cross it resulted.
5) **broods** (only for models involving hybrids): brood a hybrid belongs to, i.e. from which backcross it resulted.

While random effect 1) is absolutely necessary to include, we decided to check for all other random effects whether it makes sense to include them or not (see below).

We set some relatively weak priors for the `intercepts`{.R} and all additional `type`{.R}/`redYN`{.R}-coefficients in all models in this section. Note that these model coefficients represent the model estimators for different male types when all log-illuminance measurements are at their minimum. We use the normal distribution, with a mean of 0 and a standard deviation of 3. The used priors help us eliminate extreme preference values close to 0 and 1. Due to close relationship between the types, we don't have any clear expectation for their preferences, except that those preferences will not be close to 0 or 1. 

Note that this prior acts on the logit scale (all our models use a logit-link), so we have to inverse-logit transform our prior to make it understandable. We quickly visualize what this prior looks like when inverse-logit transformed:
```{r}
plot(plogis(seq(-5,5,0.01)),dnorm(seq(-5,5,0.01),0,3),type="l",xlab="Prior (Inverse Logit Scale)",ylab="Probability")
```

Recode contrasts (recommended to retrieve good model estimates later from `brm`{.R} model). (Another option would be using `contr.bayes`{.R}, as suggested by some people.) First, save old contrasts.
```{r}
old_contr<-options("contrasts")
options(contrasts = c("contr.sum", "contr.poly"))
```

#### Effect of type and its interaction with illuminance measures on visual mate preference in *heu* and *lin* males

##### Random effects

We first look at *heu* and *lin* males. We start off checking how stable our models will be concerning possible random effects. Possible random effects are:

* ID
* trial (potentially nested in date)
* observer

It is a common "problem" in 'Stan' models (as implemented in `brms`{.R}) that random effects (group-level effects) with only few levels lead to divergent transitions (i.e. the model basically fails converging). This problem becomes apparent for `observer`{.R} as well as if we nest `date_trial`{.R} within `data`{.R}. Although `date_trial`{.R} and `date`{.R} have a lot of different levels, if we use the nested design, we have a maximum of 5 levels of `date_trial`{.R} per group-level `date`{.R}.

We use the full model (type and both log-illuminance measures as well as all interactions as fixed effects) to test what `brms`{.R} tells us when including certain random effects.

For starters, we include ID, trial nested in date and observer as random effects.

Note that we are setting a seed within the `brm`{.R} function. 

As for all following models, we always save them as RDS object, since these models run for incredibly long. In case they are already on our disk, we just load them.
```{r}
if(file.exists("Models/mod1.0.rds")){
  mod1.0<-readRDS("Models/mod1.0.rds")
} else{
mod1.0<-suppressMessages(brm(court_lin_heu_01~type*log_light_HC*log_light_TLC+(1|ID)+(1|date/date_trial)+(1|observer),
               prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                       set_prior("normal(0,3)",class="Intercept")),
               family="bernoulli",data=pref_stat_TLC_HC,chains=5,
               iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=1))
saveRDS(mod1.0,"Models/mod1.0.rds")
}
```

We get a warning from Stan about divergent transaitions. Looking through the `Rhat`{.R}, `Bulk_ESS`{.R} and `Tail_ESS`{.R} estimates, we can see that `date`{.R} as random effect seems to cause most trouble. We see a relatively big `Rhat`{.R} (`Rhat=1`{.R} would indicate convergence) and small ESS values. (If we'd run the same model as a GLMM with the `lme4`{.R} package, we could see that the variance explained by `date`{.R} alone is very close to 0.)
```{r}
suppressWarnings(summary(mod1.0)$random$date)
```

We exclude `date`{.R} and only keep `date_trial`{.R} as random (no more nested).
```{r}
if(file.exists("Models/mod1.1.rds")){
  mod1.1<-readRDS("Models/mod1.1.rds")
} else{
mod1.1 <- suppressMessages(update(mod1.0, formula. =  ~ . + (1|date_trial) - (1|date/date_trial),refresh=0,silent = TRUE,seed=2))
saveRDS(mod1.1,"Models/mod1.1.rds")
}
```

We still get lots of warnings about divergent transitions.
Looking again at diagnostics about the model, we can see that also `observer`{.R} has a quite high `Rhat`{.R} and comparibly weak EES values (again, we would see the same in a frequentist GLMM).
```{r}
suppressWarnings(summary(mod1.1)$random$observer)
```

We discard it as well.
```{r}
if(file.exists("Models/mod1.2.rds")){
  mod1.2<-readRDS("Models/mod1.2.rds")
} else{
mod1.2 <- suppressMessages(update(mod1.1, formula. =  ~ . - (1|observer),refresh=0,silent = TRUE,seed=3))
saveRDS(mod1.2,"Models/mod1.2.rds")
}
```

No more warnings. The model seems to converge fine. We build another model reduced by `date_trial`{.R} as random effect to see how important it is.
```{r}
if(file.exists("Models/mod1.3.rds")){
  mod1.3<-readRDS("Models/mod1.3.rds")
} else{
mod1.3 <- suppressMessages(update(mod1.2, formula. =  ~ . - (1|date_trial),refresh=0,silent = TRUE,seed=4))
saveRDS(mod1.3,"Models/mod1.3.rds")
}
```

Perform approximate leave-one-out (LOO) cross-validation with `mod1.2`{.R} and `mod1.3.`{.R}
```{r}
loo_compare(list(loo(mod1.2),loo(mod1.3)))
```

Comparing ELPD and SE, we can see that `mod1.2`{.R} performs tremendously better! We find a massive ELPD-difference between the models, many folds higher than the standard error of ELPD. `date_trial`{.R} should be kept as random factor. 

We definitely want to keep `ID`{.R} as random effect as well to correct for pseudoreplication/overdispersion. Therefore we are settled on the random effects and chose `mod1.2`{.R} as blueprint for random effects design.

##### Fixed effects

Now we check which fixed effects we want to use. We try out all possible (nested/reduced) variations of the model and then use the _WAIC_ (and additionally also _LOOIC_) information criterion to assess model fit.

Because we have some `NA`{.R} observations in the log-illuminance columns, we have to create a reduced dataset, where columns with `NA`{.R} get removed. This will allow that all models will be fitted to the same dataset (otherwise, due to different involved columns, some `NA`{.R} columns will be dropped for one model, but not for the other).
```{r}
pref_stat_TLC_HC_red<-pref_stat_TLC_HC[!is.na(pref_stat_TLC_HC$log_light_HC)&!is.na(pref_stat_TLC_HC$log_light_TLC),]
#For safety, we drop levels (may cause some problems if we don't)
pref_stat_TLC_HC_red<-droplevels(pref_stat_TLC_HC_red)
```

Create reduced version of `mod1.2`{.R} (which should actually be exactly the same as `mod1.2`{.R}, since `NA`{.R}s are anyway discarded during modelling). We need to do this step so we can fit the model to the new `pref_stat_TLC_HC_red`{.R} dataset. We will below update this model (avoids compiling time), so we have to make sure it's fitted to the new dataset.
```{r}
if(file.exists("Models/mod1.2_red.rds")){
  mod1.2_red<-readRDS("Models/mod1.2_red.rds")
} else{
mod1.2_red<-suppressMessages(brm(court_lin_heu_01~type*log_light_HC*log_light_TLC+(1|ID)+(1|date_trial),
               prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                       set_prior("normal(0,3)",class="Intercept")),
               family="bernoulli",data=pref_stat_TLC_HC_red,chains=5,
               iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=5))
saveRDS(mod1.2_red,"Models/mod1.2_red.rds")
}
```

Now we run all the reduced versions of the full model. Since none of these nested variations will be needed further on, we can immediately delete them after LOOIC and WAIC was calculated. Since our RMarkdown was often crashing during LOOIC/WAIC calculation, since these models are so gigantic, we check first if the LOOIC/WAIC value already exists in our LOOIC/WAIC table, which will be in the end exported. (This was solely for us, so that when rerunning the Markdown after it crashed, Markdown could start calculations from where it crashed). We are aware that this means that the LOOIC and WAIC calculations are not perfectly reproducible on another computer and are sorry for that (however, LOOIC and WAIC commands usually result in the exact same values with different seed; they usually just differ at the tenth digit after the comma or so). For anyone wanting to reproduce our precise values: In the last run (which you see here in this Markdown), we had all models saved previously and the LOOIC and WAIC calculations ran through from first to last (suprisingly without crashing).
```{r}
#If exists, read in
if(file.exists("Tables/WAIC_pure.csv")){
  IC_table<-read.csv("Tables/WAIC_pure.csv",header=T,stringsAsFactors = F)[,1:3]
} else{
  #Make empty table
  IC_table<-data.frame(Model=character(0),
                     LOOIC=numeric(0),WAIC=numeric(0),stringsAsFactors = F)
}
```

Now produce the models (or load them), if they don't appear yet in the table. After being loaded and the WAIC/LOOIC being calculated, the models are deleted. The table is saved after each model has been finished.
```{r}
#The null model (all fixed effects and interactions removed)
if(!"mod1.200"%in%IC_table$Model){
if(file.exists("Models/mod1.200.rds")){
  mod1.200<-readRDS("Models/mod1.200.rds")
} else{
mod1.200 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type - log_light_HC - log_light_TLC - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=6))
saveRDS(mod1.200,"Models/mod1.200.rds")
}
  loo_new<-loo(mod1.200)$estimates[3,1]
  waic_new<-waic(mod1.200)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.200",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.200)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model only including type as fixed
if(!"mod1.201"%in%IC_table$Model){
if(file.exists("Models/mod1.201.rds")){
  mod1.201<-readRDS("Models/mod1.201.rds")
} else{
mod1.201 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - log_light_HC - log_light_TLC - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=7))
saveRDS(mod1.201,"Models/mod1.201.rds")
}
  loo_new<-loo(mod1.201)$estimates[3,1]
  waic_new<-waic(mod1.201)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.201",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.201)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model only including log-illuminance at heu 'female'
if(!"mod1.202"%in%IC_table$Model){
if(file.exists("Models/mod1.202.rds")){
  mod1.202<-readRDS("Models/mod1.202.rds")
} else{
mod1.202 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type - log_light_TLC - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=8))
saveRDS(mod1.202,"Models/mod1.202.rds")
}
  loo_new<-loo(mod1.202)$estimates[3,1]
  waic_new<-waic(mod1.202)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.202",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.202)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model only including log-illuminance at lin 'female'
if(!"mod1.203"%in%IC_table$Model){
if(file.exists("Models/mod1.203.rds")){
  mod1.203<-readRDS("Models/mod1.203.rds")
} else{
mod1.203 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type - log_light_HC - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=9))
saveRDS(mod1.203,"Models/mod1.203.rds")
}
  loo_new<-loo(mod1.203)$estimates[3,1]
  waic_new<-waic(mod1.203)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.203",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.203)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type and log-illuminance at heu 'female'
if(!"mod1.204"%in%IC_table$Model){
if(file.exists("Models/mod1.204.rds")){
  mod1.204<-readRDS("Models/mod1.204.rds")
} else{
mod1.204 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - log_light_TLC - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=10))
saveRDS(mod1.204,"Models/mod1.204.rds")
}
  loo_new<-loo(mod1.204)$estimates[3,1]
  waic_new<-waic(mod1.204)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.204",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.204)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type and log-illuminance at lin 'female'
if(!"mod1.205"%in%IC_table$Model){
if(file.exists("Models/mod1.205.rds")){
  mod1.205<-readRDS("Models/mod1.205.rds")
} else{
mod1.205 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - log_light_HC - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=11))
saveRDS(mod1.205,"Models/mod1.205.rds")
}
  loo_new<-loo(mod1.205)$estimates[3,1]
  waic_new<-waic(mod1.205)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.205",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.205)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including log-illuminance at heu 'female' and log-illuminance at lin 'female'
if(!"mod1.206"%in%IC_table$Model){
if(file.exists("Models/mod1.206.rds")){
  mod1.206<-readRDS("Models/mod1.206.rds")
} else{
mod1.206 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=12))
saveRDS(mod1.206,"Models/mod1.206.rds")
}
  loo_new<-loo(mod1.206)$estimates[3,1]
  waic_new<-waic(mod1.206)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.206",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.206)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female' and log-illuminance at lin 'female'
if(!"mod1.207"%in%IC_table$Model){
if(file.exists("Models/mod1.207.rds")){
  mod1.207<-readRDS("Models/mod1.207.rds")
} else{
mod1.207 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type:log_light_HC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=13))
saveRDS(mod1.207,"Models/mod1.207.rds")
}
  loo_new<-loo(mod1.207)$estimates[3,1]
  waic_new<-waic(mod1.207)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.207",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.207)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female' and their interaction
if(!"mod1.208"%in%IC_table$Model){
if(file.exists("Models/mod1.208.rds")){
  mod1.208<-readRDS("Models/mod1.208.rds")
} else{
mod1.208 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - log_light_TLC - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=14))
saveRDS(mod1.208,"Models/mod1.208.rds")
}
  loo_new<-loo(mod1.208)$estimates[3,1]
  waic_new<-waic(mod1.208)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.208",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.208)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at lin 'female' and their interaction
if(!"mod1.209"%in%IC_table$Model){
if(file.exists("Models/mod1.209.rds")){
  mod1.209<-readRDS("Models/mod1.209.rds")
} else{
mod1.209 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - log_light_HC - type:log_light_HC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=15))
saveRDS(mod1.209,"Models/mod1.209.rds")
}
  loo_new<-loo(mod1.209)$estimates[3,1]
  waic_new<-waic(mod1.209)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.209",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.209)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including log-illuminance at heu 'female', log-illuminance at lin 'female' and their interaction
if(!"mod1.210"%in%IC_table$Model){
if(file.exists("Models/mod1.210.rds")){
  mod1.210<-readRDS("Models/mod1.210.rds")
} else{
mod1.210 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type - type:log_light_HC - type:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=16))
saveRDS(mod1.210,"Models/mod1.210.rds")
}
  loo_new<-loo(mod1.210)$estimates[3,1]
  waic_new<-waic(mod1.210)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.210",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.210)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female', log-illuminance at lin 'female' and the interaction between type and log-illuminance at heu 'female'
if(!"mod1.211"%in%IC_table$Model){
if(file.exists("Models/mod1.211.rds")){
  mod1.211<-readRDS("Models/mod1.211.rds")
} else{
mod1.211 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type:log_light_TLC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=17))
saveRDS(mod1.211,"Models/mod1.211.rds")
}
  loo_new<-loo(mod1.211)$estimates[3,1]
  waic_new<-waic(mod1.211)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.211",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.211)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female', log-illuminance at lin 'female' and the interaction between type and log-illuminance at lin 'female'
if(!"mod1.212"%in%IC_table$Model){
if(file.exists("Models/mod1.212.rds")){
  mod1.212<-readRDS("Models/mod1.212.rds")
} else{
mod1.212 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type:log_light_HC - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=18))
saveRDS(mod1.212,"Models/mod1.212.rds")
}
  loo_new<-loo(mod1.212)$estimates[3,1]
  waic_new<-waic(mod1.212)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.212",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.212)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female', log-illuminance at lin 'female' and the interaction between the two log-illuminance measures
if(!"mod1.213"%in%IC_table$Model){
if(file.exists("Models/mod1.213.rds")){
  mod1.213<-readRDS("Models/mod1.213.rds")
} else{
mod1.213 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type:log_light_HC - type:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=19))
saveRDS(mod1.213,"Models/mod1.213.rds")
}
  loo_new<-loo(mod1.213)$estimates[3,1]
  waic_new<-waic(mod1.213)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.213",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.213)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female', log-illuminance at lin 'female', the interaction between type and log-illuminance at heu 'female' and the interaction between the two log-illuminance measures
if(!"mod1.214"%in%IC_table$Model){
if(file.exists("Models/mod1.214.rds")){
  mod1.214<-readRDS("Models/mod1.214.rds")
} else{
mod1.214 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=20))
saveRDS(mod1.214,"Models/mod1.214.rds")
}
  loo_new<-loo(mod1.214)$estimates[3,1]
  waic_new<-waic(mod1.214)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.214",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.214)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female', log-illuminance at lin 'female', the interaction between type and log-illuminance at lin 'female' and the interaction between the two log-illuminance measures
if(!"mod1.215"%in%IC_table$Model){
if(file.exists("Models/mod1.215.rds")){
  mod1.215<-readRDS("Models/mod1.215.rds")
} else{
mod1.215 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type:log_light_HC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=21))
saveRDS(mod1.215,"Models/mod1.215.rds")
}
  loo_new<-loo(mod1.215)$estimates[3,1]
  waic_new<-waic(mod1.215)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.215",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.215)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female', log-illuminance at lin 'female', the interaction between type and log-illuminance at heu 'female' and the interaction between type and log-illuminance at lin 'female'
if(!"mod1.216"%in%IC_table$Model){
if(file.exists("Models/mod1.216.rds")){
  mod1.216<-readRDS("Models/mod1.216.rds")
} else{
mod1.216 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - log_light_HC:log_light_TLC - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=22))
saveRDS(mod1.216,"Models/mod1.216.rds")
}
  loo_new<-loo(mod1.216)$estimates[3,1]
  waic_new<-waic(mod1.216)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.216",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.216)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
#The model including type, log-illuminance at heu 'female', log-illuminance at lin 'female' and all two-way interactions
if(!"mod1.217"%in%IC_table$Model){
if(file.exists("Models/mod1.217.rds")){
  mod1.217<-readRDS("Models/mod1.217.rds")
} else{
mod1.217 <- suppressMessages(update(mod1.2_red, formula. =  ~ . - type:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=23))
saveRDS(mod1.217,"Models/mod1.217.rds")
}
  loo_new<-loo(mod1.217)$estimates[3,1]
  waic_new<-waic(mod1.217)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.217",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.217)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
```

now, we calculate WAIC and LOOIC of the full model.
```{r}
if(!"mod1.2_red"%in%IC_table$Model){
  loo_new<-loo(mod1.2_red)$estimates[3,1]
  waic_new<-waic(mod1.2_red)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod1.2_red",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod1.2_red)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
}
```

To create model weights based on WAIC, we use the exact same code as the `model_weights`{.R} function of `brms`{.R} would do. We calculate it here manually, since the `model_weights`{.R} function would otherwise calculate all WAIC values again (which would cost time and we'd also have to be careful with settings seeds, since WAIC calculation relies on the random number generator). 
```{r}
ic_diffs <- IC_table$WAIC - min(IC_table$WAIC)
out <- exp(-ic_diffs / 2)
out <- as.numeric(out)
out <- out / sum(out)
```

We summarize LOOIC, WAIC and WAIC weights in a table, and additionally calculate WAIC differences between best fitting model and the other models. We then sort this table by WAIC value and view it.
```{r rows.print=19}
IC_table<-data.frame(IC_table,WAIC_Diff=ic_diffs,WAIC_weight=out)
IC_table<-IC_table[order(IC_table$WAIC),]
print(cbind(Model=IC_table[,1],round(IC_table[,-1],2)))
```

We can see that the six models, which include the interaction term between `type`{.R} and log-illuminance at the *heu* 'female' are the six best fitting models. If we add all their model weights up, we can see that these models have a high weight together:
```{r}
print(round(sum(IC_table$WAIC_weight[1:6]),2))
```

We can see that the model with the best fit is `mod1.208`{.R}, which includes `type`{.R}, log-illuminance at *heu* 'female' and their interaction.

We safe this table:
```{r}
write.csv(IC_table,"Tables/WAIC_pure.csv",row.names=F,quote=F)
```

We also generate "categorical" illuminance models, where we split log-illuminance at the *heu* model and at the *lin* into dark and bright, following the median measurements of the dataset. We have to add two new columns for that, putting rows into each of the two times two classes. 
```{r}
pref_stat_TLC_HC$quantile_low_up_1<-as.integer(cut(pref_stat_TLC_HC$log_light_HC, quantile(pref_stat_TLC_HC$log_light_HC, probs=c(0,0.5,1),na.rm = T), include.lowest=TRUE))
pref_stat_TLC_HC$quantile_low_up_1<-paste0("q",pref_stat_TLC_HC$quantile_low_up_1)
pref_stat_TLC_HC$quantile_low_up_1[pref_stat_TLC_HC$quantile_low_up_1=="qNA"]<-NA
pref_stat_TLC_HC$quantile_low_up_2<-as.integer(cut(pref_stat_TLC_HC$log_light_TLC, quantile(pref_stat_TLC_HC$log_light_TLC, probs=c(0,0.5,1),na.rm = T), include.lowest=TRUE))
pref_stat_TLC_HC$quantile_low_up_2<-paste0("q",pref_stat_TLC_HC$quantile_low_up_2)
pref_stat_TLC_HC$quantile_low_up_2[pref_stat_TLC_HC$quantile_low_up_2=="qNA"]<-NA
```

We again run all the 19 possible nested categorical models, just as we did before for the continuous data.

The full model based on the reduced dataset (i.e. without `NA`{.R}):
```{r}
if(file.exists("Models/mod_CAT_1.2_red.rds")){
  mod_CAT_1.2_red<-readRDS("Models/mod_CAT_1.2_red.rds")
} else{
  mod_CAT_1.2_red<-suppressMessages(brm(court_lin_heu_01~type*quantile_low_up_1*quantile_low_up_2+(1|ID)+(1|date_trial),
                                        prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                                                set_prior("normal(0,3)",class="Intercept")),
                                        family="bernoulli",data=pref_stat_TLC_HC_red,chains=5,
                                        iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=5))
  saveRDS(mod_CAT_1.2_red,"Models/mod_CAT_1.2_red.rds")
}
```

Load/create the results table
```{r}
#If exists, read in
if(file.exists("Tables/WAIC_pure_CAT.csv")){
  IC_table<-read.csv("Tables/WAIC_pure_CAT.csv",header=T,stringsAsFactors = F)[,1:3]
} else{
  #Make empty table
  IC_table<-data.frame(Model=character(0),
                       LOOIC=numeric(0),WAIC=numeric(0),stringsAsFactors = F)
}
```

And all other variations...
```{r}
#The null model (all fixed effects and interactions removed)
if(!"mod_CAT_1.200"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.200.rds")){
  mod_CAT_1.200<-readRDS("Models/mod_CAT_1.200.rds")
} else{
mod_CAT_1.200 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type - quantile_low_up_1 - quantile_low_up_2 - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=6))
saveRDS(mod_CAT_1.200,"Models/mod_CAT_1.200.rds")
}
  loo_new<-loo(mod_CAT_1.200)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.200)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.200",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.200)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model only including type as fixed
if(!"mod_CAT_1.201"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.201.rds")){
  mod_CAT_1.201<-readRDS("Models/mod_CAT_1.201.rds")
} else{
mod_CAT_1.201 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - quantile_low_up_1 - quantile_low_up_2 - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=7))
saveRDS(mod_CAT_1.201,"Models/mod_CAT_1.201.rds")
}
  loo_new<-loo(mod_CAT_1.201)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.201)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.201",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.201)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model only including categorical illuminance at heu 'female'
if(!"mod_CAT_1.202"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.202.rds")){
  mod_CAT_1.202<-readRDS("Models/mod_CAT_1.202.rds")
} else{
mod_CAT_1.202 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type - quantile_low_up_2 - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=8))
saveRDS(mod_CAT_1.202,"Models/mod_CAT_1.202.rds")
}
  loo_new<-loo(mod_CAT_1.202)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.202)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.202",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.202)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model only including categorical illuminance at lin 'female'
if(!"mod_CAT_1.203"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.203.rds")){
  mod_CAT_1.203<-readRDS("Models/mod_CAT_1.203.rds")
} else{
mod_CAT_1.203 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type - quantile_low_up_1 - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=9))
saveRDS(mod_CAT_1.203,"Models/mod_CAT_1.203.rds")
}
  loo_new<-loo(mod_CAT_1.203)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.203)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.203",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.203)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type and categorical illuminance at heu 'female'
if(!"mod_CAT_1.204"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.204.rds")){
  mod_CAT_1.204<-readRDS("Models/mod_CAT_1.204.rds")
} else{
mod_CAT_1.204 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - quantile_low_up_2 - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=10))
saveRDS(mod_CAT_1.204,"Models/mod_CAT_1.204.rds")
}
  loo_new<-loo(mod_CAT_1.204)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.204)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.204",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.204)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type and categorical illuminance at lin 'female'
if(!"mod_CAT_1.205"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.205.rds")){
  mod_CAT_1.205<-readRDS("Models/mod_CAT_1.205.rds")
} else{
mod_CAT_1.205 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - quantile_low_up_1 - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=11))
saveRDS(mod_CAT_1.205,"Models/mod_CAT_1.205.rds")
}
  loo_new<-loo(mod_CAT_1.205)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.205)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.205",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.205)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including categorical illuminance at heu 'female' and categorical illuminance at lin 'female'
if(!"mod_CAT_1.206"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.206.rds")){
  mod_CAT_1.206<-readRDS("Models/mod_CAT_1.206.rds")
} else{
mod_CAT_1.206 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=12))
saveRDS(mod_CAT_1.206,"Models/mod_CAT_1.206.rds")
}
  loo_new<-loo(mod_CAT_1.206)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.206)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.206",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.206)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female' and categorical illuminance at lin 'female'
if(!"mod_CAT_1.207"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.207.rds")){
  mod_CAT_1.207<-readRDS("Models/mod_CAT_1.207.rds")
} else{
mod_CAT_1.207 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type:quantile_low_up_1 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=13))
saveRDS(mod_CAT_1.207,"Models/mod_CAT_1.207.rds")
}
  loo_new<-loo(mod_CAT_1.207)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.207)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.207",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.207)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female' and their interaction
if(!"mod_CAT_1.208"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.208.rds")){
  mod_CAT_1.208<-readRDS("Models/mod_CAT_1.208.rds")
} else{
mod_CAT_1.208 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - quantile_low_up_2 - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=14))
saveRDS(mod_CAT_1.208,"Models/mod_CAT_1.208.rds")
}
  loo_new<-loo(mod_CAT_1.208)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.208)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.208",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.208)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at lin 'female' and their interaction
if(!"mod_CAT_1.209"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.209.rds")){
  mod_CAT_1.209<-readRDS("Models/mod_CAT_1.209.rds")
} else{
mod_CAT_1.209 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - quantile_low_up_1 - type:quantile_low_up_1 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=15))
saveRDS(mod_CAT_1.209,"Models/mod_CAT_1.209.rds")
}
  loo_new<-loo(mod_CAT_1.209)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.209)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.209",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.209)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including categorical illuminance at heu 'female', categorical illuminance at lin 'female' and their interaction
if(!"mod_CAT_1.210"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.210.rds")){
  mod_CAT_1.210<-readRDS("Models/mod_CAT_1.210.rds")
} else{
mod_CAT_1.210 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type - type:quantile_low_up_1 - type:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=16))
saveRDS(mod_CAT_1.210,"Models/mod_CAT_1.210.rds")
}
  loo_new<-loo(mod_CAT_1.210)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.210)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.210",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.210)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and the interaction between type and categorical illuminance at heu 'female'
if(!"mod_CAT_1.211"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.211.rds")){
  mod_CAT_1.211<-readRDS("Models/mod_CAT_1.211.rds")
} else{
mod_CAT_1.211 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=17))
saveRDS(mod_CAT_1.211,"Models/mod_CAT_1.211.rds")
}
  loo_new<-loo(mod_CAT_1.211)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.211)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.211",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.211)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and the interaction between type and categorical illuminance at lin 'female'
if(!"mod_CAT_1.212"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.212.rds")){
  mod_CAT_1.212<-readRDS("Models/mod_CAT_1.212.rds")
} else{
mod_CAT_1.212 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type:quantile_low_up_1 - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=18))
saveRDS(mod_CAT_1.212,"Models/mod_CAT_1.212.rds")
}
  loo_new<-loo(mod_CAT_1.212)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.212)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.212",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.212)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and the interaction between the two categorical illuminance measures
if(!"mod_CAT_1.213"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.213.rds")){
  mod_CAT_1.213<-readRDS("Models/mod_CAT_1.213.rds")
} else{
mod_CAT_1.213 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type:quantile_low_up_1 - type:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=19))
saveRDS(mod_CAT_1.213,"Models/mod_CAT_1.213.rds")
}
  loo_new<-loo(mod_CAT_1.213)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.213)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.213",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.213)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female', categorical illuminance at lin 'female', the interaction between type and categorical illuminance at heu 'female' and the interaction between the two categorical illuminance measures
if(!"mod_CAT_1.214"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.214.rds")){
  mod_CAT_1.214<-readRDS("Models/mod_CAT_1.214.rds")
} else{
mod_CAT_1.214 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=20))
saveRDS(mod_CAT_1.214,"Models/mod_CAT_1.214.rds")
}
  loo_new<-loo(mod_CAT_1.214)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.214)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.214",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.214)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female', categorical illuminance at lin 'female', the interaction between type and categorical illuminance at lin 'female' and the interaction between the two categorical illuminance measures
if(!"mod_CAT_1.215"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.215.rds")){
  mod_CAT_1.215<-readRDS("Models/mod_CAT_1.215.rds")
} else{
mod_CAT_1.215 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type:quantile_low_up_1 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=21))
saveRDS(mod_CAT_1.215,"Models/mod_CAT_1.215.rds")
}
  loo_new<-loo(mod_CAT_1.215)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.215)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.215",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.215)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female', categorical illuminance at lin 'female', the interaction between type and categorical illuminance at heu 'female' and the interaction between type and categorical illuminance at lin 'female'
if(!"mod_CAT_1.216"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.216.rds")){
  mod_CAT_1.216<-readRDS("Models/mod_CAT_1.216.rds")
} else{
mod_CAT_1.216 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - quantile_low_up_1:quantile_low_up_2 - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=22))
saveRDS(mod_CAT_1.216,"Models/mod_CAT_1.216.rds")
}
  loo_new<-loo(mod_CAT_1.216)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.216)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.216",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.216)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
#The model including type, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and all two-way interactions
if(!"mod_CAT_1.217"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_1.217.rds")){
  mod_CAT_1.217<-readRDS("Models/mod_CAT_1.217.rds")
} else{
mod_CAT_1.217 <- suppressMessages(update(mod_CAT_1.2_red, formula. =  ~ . - type:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=23))
saveRDS(mod_CAT_1.217,"Models/mod_CAT_1.217.rds")
}
  loo_new<-loo(mod_CAT_1.217)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.217)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.217",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_1.217)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
```

now, we calculate WAIC and LOOIC of the full model.
```{r}
if(!"mod_CAT_1.2_red"%in%IC_table$Model){
  loo_new<-loo(mod_CAT_1.2_red)$estimates[3,1]
  waic_new<-waic(mod_CAT_1.2_red)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_1.2_red",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
  rm(mod_CAT_1.2_red)
  invisible(gc())
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
}
```

WAIC weights.
```{r}
ic_diffs <- IC_table$WAIC - min(IC_table$WAIC)
out <- exp(-ic_diffs / 2)
out <- as.numeric(out)
out <- out / sum(out)
```

We summarize LOOIC, WAIC and WAIC weights in a table, and additionally calculate WAIC differences between best fitting model and the other models. We then sort this table by WAIC value and view it.
```{r rows.print=19}
IC_table<-data.frame(IC_table,WAIC_Diff=ic_diffs,WAIC_weight=out)
IC_table<-IC_table[order(IC_table$WAIC),]
print(cbind(Model=IC_table[,1],round(IC_table[,-1],2)))
```

We can see that the categorical data support the same model structure as the continuous data, i.e. the model including male type, log-illuminance at the *heu* model and their interaction. Again, the best fitting models all include the interaction between male type, log-illuminance at the *heu* model; just this time, one of the six models that include this interaction is not in the "Top 6"; the full model with three-way interaction.

We save the table.
```{r}
write.csv(IC_table,"Tables/WAIC_pure_CAT.csv",row.names=F,quote=F)
```

The model for the continuous as well as for the categorical data agree! We therefore settle for model structure `mod1.208`{.R}. We fit the continuous model again, but now to the full dataset (this should result in almost the same model, since almost all `NA`{.R} rows were shared between `log_light_HC`{.R} and `log_light_TLC`{.R}). We fit it explicitely here (without the `update()`{.R} function), so it's better visible how the model looks like. We use the same seed as before (which though shouldn't play any role, since we use a new dataset).
```{r}
if(file.exists("Models/mod1.208_final.rds")){
  mod1.208_final<-readRDS("Models/mod1.208_final.rds")
} else{
mod1.208_final<-suppressMessages(brm(court_lin_heu_01~type*log_light_HC+(1|ID)+(1|date_trial),
               prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                       set_prior("normal(0,3)",class="Intercept")),
               family="bernoulli",data=pref_stat_TLC_HC,chains=5,
               iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=14))
saveRDS(mod1.208_final,"Models/mod1.208_final.rds")
}
```

To correct for the broad light environment in which lux was recorded, we scored whether the *heu* mounted female was in treeshade, i.e. other regions of the experimental cage were sunny, but the mounted female was in the shade. In such light environment, the spectrum of light falling into the cage would be blue-biased. All other light environments in our experiment are expected to have a flat spectrum, i.e. lux is a decent approximation for the intensity of long-wavelength/red light getting into the cage (red light is what matters for the contrast of the red band). Therefore we have to multiply measurements from the treeshade environment by a factor X, which downregulates the overestimation of long-wavelength light done by the logger. We estimated X to be 0.85, based on the spectral sensitivity of our light logger and Fig. 8 from Endler 1993 Ecol. Monogr.; `log_light_HC_corrected`{.R} is the name of the corrected column, where we take the log10 of the corrected lux values.
```{r}
pref_stat_TLC_HC$light_HC_corrected<-pref_stat_TLC_HC$light_HC
check_for_blue<-pref_stat_TLC_HC$light_class_HC=="sunny_but_treeshade"
check_for_blue<-ifelse(is.na(check_for_blue),FALSE,check_for_blue)
tree_corrected<-pref_stat_TLC_HC$light_HC_corrected[check_for_blue]*0.85
pref_stat_TLC_HC$light_HC_corrected[check_for_blue]<-tree_corrected
pref_stat_TLC_HC$log_light_HC_corrected<-log10(pref_stat_TLC_HC$light_HC_corrected)
```

Before we run this model, we run another model checking if our observations by eye match with the light logger scores. We build a model where we explain male preference by male type, the light environment class and their interaction. To recall, we scored three light environment classes, "sunny", "cloudy" and "woodland shade". This model will be visualized later in this Markdown.
```{r}
if(file.exists("Models/mod1.208_light_cat.rds")){
  mod1.208_light_cat<-readRDS("Models/mod1.208_light_cat.rds")
} else{
mod1.208_light_cat<-suppressMessages(brm(court_lin_heu_01~type*light_class_HC+(1|ID)+(1|date_trial),
                                         prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                                                 set_prior("normal(0,3)",class="Intercept")),
                                         family="bernoulli",data=pref_stat_TLC_HC,chains=5,
                                         iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=14))
saveRDS(mod1.208_light_cat,"Models/mod1.208_light_cat.rds")
}
```

Now we run the model with the corrected log-illuminance values:
```{r}
if(file.exists("Models/mod1.208_corrected_final.rds")){
  mod1.208_corrected_final<-readRDS("Models/mod1.208_corrected_final.rds")
} else{
mod1.208_corrected_final<-suppressMessages(brm(court_lin_heu_01~type*log_light_HC_corrected+(1|ID)+(1|date_trial),
                                               prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                                                       set_prior("normal(0,3)",class="Intercept")),
                                               family="bernoulli",data=pref_stat_TLC_HC,chains=5,
                                               iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=14))
saveRDS(mod1.208_corrected_final,"Models/mod1.208_corrected_final.rds")
}
```

We also re-run the best-fitting categorical model with the full dataset.
```{r}
#Exclude NA measurements
if(file.exists("Models/mod1.208_cat.rds")){
  mod1.208_cat<-readRDS("Models/mod1.208_cat.rds")
} else{
mod1.208_cat<-suppressMessages(brm(court_lin_heu_01~type*quantile_low_up_1+(1|ID)+(1|date_trial),
                                   prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                                           set_prior("normal(0,3)",class="Intercept")),
                                   family="bernoulli",data=pref_stat_TLC_HC,chains=5,
                                   iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=14))
saveRDS(mod1.208_cat,"Models/mod1.208_cat.rds")
}
```

We return back to the main model fitted to the continuous data.

Let's do some quick model checking. We see "hairy caterpillars" in the trace plots on the right, which is a good sign (the MCMC algorithm covered parameter space well)!
```{r}
plot(mod1.208_final)
```

Some posterior predictive checks to compare model predictions to actual data. Looks like a good fit!
```{r}
suppressMessages(pp_check(mod1.208_final))
```

Now let's have a quick look at the model coefficients. Annotation of `type`{.R} is numeric due to `contr.sum()`{.R} dummy coding:
```{r}
print(fixef(mod1.208_final)[,1])
```

Next, we want to look at model estimators (estimated marginal means) and contrasts. We use the awesome `emmeans`{.R} package to extract posteriors for estimators and contrasts.

For this, we first define two functions which will help handle the `emmeans`{.R} output.

This function transforms the posteriors stored in an `emmeans`{.R} output to a more user-friendly table. This function does essentially the same as `as.mcmc.emmGrid`{.R} from `emmeans`{.R} or `gather_emmeans_draws`{.R} from the `tidybayes`{.R} package. This just produces a handier format, as we think (all values below each other with an identifier column, as in `gather_emmeans_draws`{.R}, but with 'non-tidy' format):
```{r}
extract_emm_post<-function(emm_object){
  
  #Get parameter combinations
  level_comb<-expand.grid(emm_object@levels,stringsAsFactors=F)
  #Get number of elements per posterior
  iterat<-nrow(emm_object@post.beta)
  
  #We need to do matrix multiplication of the posterior slot to get the posteriors relating to the emmeans output (in some cases, this step is not necessary, but it doesn't matter to do it anyways):  
  slopes<-emm_object@post.beta%*%t(emm_object@linfct)
  
    #Append each posterior and give parameter combination and iteration ID
post_out<-data.frame(level_comb[rep(seq_len(nrow(level_comb)),each=iterat),,drop=F],iteration=rep(1:iterat,nrow(level_comb)),value=as.vector(slopes),stringsAsFactors=F)

  #Remove row names and return
  rownames(post_out)<-NULL
  return(post_out)
}
```

This function calculates a credible interval and a point estimate for different posteriors from an `emmeans`{.R} output. `emmeans`{.R} does already return such summaries, but it defaults to pass the median and the 95% high-density interval of a posterior. This function allows to extract instead the mean (decided by `middle`{.R} argument) and/or the 95% equal-tailed interval (decided by `type0.95`{.R} argument), if wished.
```{r}
extract_emm_cri<-function(emm_object,middle="mean",type0.95="eti"){
  
  #Get parameter combinations
  level_comb<-expand.grid(emm_object@levels,stringsAsFactors=F)

  #We need to do matrix multiplication of the posterior slot to get the posteriors relating to the emmeans output (in some cases, this step is not necessary):  
  slopes<-emm_object@post.beta%*%t(emm_object@linfct)
  #If equal-tailed interval, calculate this for posteriors of each parameter combination
  if(type0.95=="eti"){
    it_over<-prod(lengths(emm_object@levels))
    to_transp<-sapply(1:it_over,function(x) c(eval(parse(text=paste0(middle,"(slopes[,x])"))),
                                              quantile(slopes[,x],probs=c(0.025,0.975))))
    summ_estimators<-data.frame(level_comb,
                                t(to_transp))
    #If not equal-tailed interval, calculate high-density interval for posteriors of each parameter combination
  } else{
    #For this, we have to load the HDInterval library (this will actually never happen in this Markdown, which is why we didn't do so in the beginning).
    if(!"HDInterval"%in% rownames(installed.packages())){
      install.packages("HDInterval")
    }
    suppressMessages(suppressWarnings(library(HDInterval)))
    
    it_over<-prod(lengths(emm_object@levels))
    to_transp<-sapply(1:it_over,function(x) c(eval(parse(text=paste0(middle,"(slopes[,x])"))),
                                              hdi(slopes[,x])))
    summ_estimators<-data.frame(level_comb,
                                t(to_transp))
  }
  
  #Give names to the new table and return
  names(summ_estimators)<-c(names(emm_object@levels),"estimate","lower","upper")
  return(summ_estimators)
}
```

Let's look at the credible intervals for `type`{.R} alone. We first create an `emmeans`{.R} object.
```{r}
group_est_main<-suppressWarnings(suppressMessages(emmeans(mod1.208_final, ~type, transform="response")))
```

We could call the `extract_emm_cri`{.R} function we just created; but for now, we actually also need the posteriors, so we do this manually.
We extract the posteriors.
```{r}
group_post_main<-extract_emm_post(group_est_main)
```

Split posteriors by type
```{r}
TLC_post_main<-group_post_main$value[group_post_main$type=="TLC"]
HC_post_main<-group_post_main$value[group_post_main$type=="HC"]
```

Create "difference posterior"
```{r}
difference_post_main<-HC_post_main-TLC_post_main
```

Now we take a look at mean and 95% CrI for *lin*, *heu* and the difference between them.
```{r}
est_types<-data.frame(c("TLC","HC","HC-TLC"),rbind(c(mean(TLC_post_main),quantile(TLC_post_main,probs=c(0.025,0.975))),c(mean(HC_post_main),quantile(HC_post_main,probs=c(0.025,0.975))),c(mean(difference_post_main),quantile(difference_post_main,probs=c(0.025,0.975)))))
names(est_types)<-c("object","mean","lower","upper")
print(est_types)
```

We see an effect size of about `r round(mean(difference_post_main),2)`.

Now we test how likely it is that the predictors for *lin* and *heu* differ. We test three hypotheses:

1) *lin* males have a smaller preference score than *heu* males.
2) *heu* males show a preference for their own type. 
3) *lin* males show a preference for their own type.

While hypothesis 1) is of high interest, 2) and 3) don't matter very much. 0.5 is a meaningless "null-hypothesis", which doesn'tmake much sense when testing males with dead, mounted females. What matters is that their visual attraction diverges!
```{r}
print(data.frame(test=c("HC-TLC > 0","HC > 0","TLC < 0"),posterior_prop=c(sum(difference_post_main>0)/length(difference_post_main),sum(HC_post_main>0.5)/length(HC_post_main),sum(TLC_post_main<0.5)/length(TLC_post_main))))
```

We can see that the posterior overlap of the two predictors is small! Therefore it is very probable that the preference of the two male types differ. The probability for *heu* males to have a preference for their own type (>0.5) is smaller than for *lin* males (<0.5).

Now, let's look at the **simple** slopes of the interaction terms between `type`{.R} and log-illuminance at the *heu* 'female'.

This gets us the 'simple slopes' from the interaction term. We use the `emtrends`{.R} function for that.
```{r}
group_est_main_interact<-suppressWarnings(suppressMessages(emtrends(mod1.208_final, ~ type, var="log_light_HC",transform="response")))
```

Note: this is not the true slope at all points along the gradient. The interaction term is in fact not linear. Retrieving the **simple** slope is the general solution to describe the 'trend' of an interaction. What matters to us now is into which direction these two slopes differ from 0 and if they are different from each other.

We print the mean and 95% equal-tailed interval for these slopes.
```{r}
print(extract_emm_cri(group_est_main_interact))
```

We get the posteriors for the simple slopes
```{r}
group_post_main_interact<-extract_emm_post(group_est_main_interact)
```

We get a difference posterior for the slopes.
```{r}
slope_HC<-group_post_main_interact$value[group_post_main_interact$type=="HC"]
slope_TLC<-group_post_main_interact$value[group_post_main_interact$type=="TLC"]
difference_post_slopes<-slope_HC-slope_TLC
```


We use the same hypotheses as before. In the interaction term context, they mean something slightly different though.

1) The slope of the interaction term between *lin* and log-illuminance at *heu* 'female' is smaller than that of the interaction term between *heu* and log-illuminance at *heu* 'female'.
2) Increase in log-illuminance around the *heu* 'female' leads to an increase in preference of *heu* males for their own type (positive slope). 
3) Increase in log-illuminance around the *heu* 'female' leads to an increase in preference of *lin* males for their own type (negative slope).
```{r}
iterations<-nrow(group_post_main_interact)/2
prop_HC_bigger_TLC<-sum(difference_post_slopes>0)/iterations
prop_HC_bigger_0<-sum(slope_HC>0)/iterations
prop_TLC_bigger_0<-sum(slope_TLC<0)/iterations
print(data.frame(test=c("HC > TLC","HC > 0","TLC < 0"),
                 posterior_prob=c(prop_HC_bigger_TLC,prop_HC_bigger_0,prop_TLC_bigger_0)))
```

We can see that with a high probability, the slopes of the two interaction terms differ. The posteriors barely overlap. The slope for *heu* males is with very high probability positive. The slope of *lin* males is negative with quite high probability, but the effect is less clear.

We repeat a similar procedure with the categorical illuminace model, `mod1.208_cat`{.R}.

Extract the posteriors for all levels of type from the categorical model, under varying categorical illumination at *heu* model
```{r}
group_est_cat<-suppressWarnings(suppressMessages(emmeans(mod1.208_cat, ~type|quantile_low_up_1, transform="response")))
```

We extract the posteriors.
```{r}
group_post_cat<-extract_emm_post(group_est_cat)
```

Split posteriors by type and illuminance
```{r}
TLC_post_cat_1<-group_post_cat$value[group_post_cat$type=="TLC"&group_post_cat$quantile_low_up_1=="q1"]
HC_post_cat_1<-group_post_cat$value[group_post_cat$type=="HC"&group_post_cat$quantile_low_up_1=="q1"]
TLC_post_cat_2<-group_post_cat$value[group_post_cat$type=="TLC"&group_post_cat$quantile_low_up_1=="q2"]
HC_post_cat_2<-group_post_cat$value[group_post_cat$type=="HC"&group_post_cat$quantile_low_up_1=="q2"]
```

Create "difference posteriors"
```{r}
difference_post_cat_1<-HC_post_cat_1-TLC_post_cat_1
difference_post_cat_2<-HC_post_cat_2-TLC_post_cat_2
```

Now we take a look at mean and 95% CrI for *lin*, *heu* and the difference between them.
```{r}
est_types<-data.frame(rep(c("TLC","HC","HC-TLC"),2),rep(c("dark","bright"),each=3),rbind(c(mean(TLC_post_cat_1),quantile(TLC_post_cat_1,probs=c(0.025,0.975))),c(mean(HC_post_cat_1),quantile(HC_post_cat_1,probs=c(0.025,0.975))),c(mean(difference_post_cat_1),quantile(difference_post_cat_1,probs=c(0.025,0.975))),c(mean(TLC_post_cat_2),quantile(TLC_post_cat_2,probs=c(0.025,0.975))),c(mean(HC_post_cat_2),quantile(HC_post_cat_2,probs=c(0.025,0.975))),c(mean(difference_post_cat_2),quantile(difference_post_cat_2,probs=c(0.025,0.975)))))
names(est_types)<-c("object","light_env_heu","mean","lower","upper")
print(est_types)
```

Looks pretty similar to the continuous model!

To check if it is really log-illuminance at the *heu* 'female' and not log-illuminance in general driving this difference, we now test the effect of the two log-illuminance measures from the full model `mod1.2`{.R}. This model includes `type`{.R}, and log-illuminance measures at the two mounted females, as well as all possible interactions. We now only look at the two-way interactions; for a visualization of the three-way interaction, see later.

The description of the following is reduced to the minimum, since it's basically a repetition of what we just did.

First, we repeat what we just did for the main model, and estimate the interaction term with log-illuminance at the *heu* model.
```{r}
group_est_three_way_HC<-suppressWarnings(suppressMessages(emtrends(mod1.2, ~ type, var="log_light_HC",transform="response")))
group_post_three_way_HC<-extract_emm_post(group_est_three_way_HC)
iterations<-nrow(group_post_three_way_HC)/2
HC_post<-group_post_three_way_HC$value[group_post_three_way_HC$type=="HC"]
TLC_post<-group_post_three_way_HC$value[group_post_three_way_HC$type=="TLC"]
print(data.frame(test=c("HC > TLC","HC > 0","TLC < 0"),
                 posterior_prob=c(sum(HC_post>TLC_post)/iterations,sum(HC_post>0)/iterations,sum(TLC_post<0)/iterations)))
```

Looks the same. Now we repeat the same for the interaction term with log-illuminance at the *lin* model. We use the same hypotheses, i.e. that more intense light on the 'female' increase preference for own female type in both male types, and that both responses are in opposite directions.
```{r}
group_est_three_way_TLC<-suppressWarnings(suppressMessages(emtrends(mod1.2, ~ type, var="log_light_TLC",transform="response")))
group_post_three_way_TLC<-extract_emm_post(group_est_three_way_TLC)
iterations<-nrow(group_post_three_way_TLC)/2
HC_post<-group_post_three_way_TLC$value[group_post_three_way_TLC$type=="HC"]
TLC_post<-group_post_three_way_TLC$value[group_post_three_way_TLC$type=="TLC"]
print(data.frame(test=c("HC > TLC","HC > 0","TLC < 0"),
                 posterior_prob=c(sum(HC_post>TLC_post)/iterations,sum(HC_post>0)/iterations,
                                  sum(TLC_post<0)/iterations)))
```

We see very weak support for log-illuminance at the *lin* 'female' having much of an effect (posterior probabilities are neither close to 1, nor to 0). It's clear that light at the *lin* 'female' seems to not affect preference of either type very much.

Finally, we look at the "corrected" log-illuminance scores and check if the slopes for *heu* and *lin* males differ in this model, and also if the slopes from this corrected model differ from the model without correction.

This gets us the 'simple slopes' from the interaction term.
```{r}
#Redefine for aesthetics of Markdown
mod_temp<-mod1.208_corrected_final
group_est_main_interact_corrected<-suppressWarnings(suppressMessages(emtrends(mod_temp, ~ type, var="log_light_HC_corrected",transform="response")))
```

We print the mean and 95% equal-tailed interval for these slopes.
```{r}
print(extract_emm_cri(group_est_main_interact_corrected))
```

It seems they are very similar to the model with uncorrected values!

We get the posteriors for the simple slopes
```{r}
group_post_main_interact_corrected<-extract_emm_post(group_est_main_interact_corrected)
```

We get a difference posterior for the slopes.
```{r}
#Redine for Markdown aesthetics
av_type<-group_post_main_interact_corrected$type
difference_post_slopes_corrected<-group_post_main_interact_corrected$value[av_type=="HC"]-group_post_main_interact_corrected$value[av_type=="TLC"]
```

First, test again the following hypothesis:

1) The slope of the interaction term between *lin* and log-illuminance at *heu* 'female' is smaller than that of the interaction term between *heu* and log-illuminance at *heu* 'female'.
2) Increase in log-illuminance around the *heu* 'female' leads to an increase in preference of *heu* males for their own type (positive slope). 
3) Increase in log-illuminance around the *heu* 'female' leads to an increase in preference of *lin* males for their own type (negative slope).
```{r}
iterations<-nrow(group_post_main_interact_corrected)/2
HC_check<-group_post_main_interact_corrected$type=="HC"
TLC_check<-group_post_main_interact_corrected$type=="TLC"
slope_HC_corr<-group_post_main_interact_corrected$value[HC_check]
slope_TLC_corr<-group_post_main_interact_corrected$value[TLC_check]
print(data.frame(test=c("HC > TLC","HC > 0","TLC < 0"),
                 posterior_prob=c(sum(difference_post_slopes_corrected>0)/iterations,sum(slope_HC_corr>0)/iterations,
                                  sum(slope_TLC_corr<0)/iterations)))
```

Again, with high probability, the slopes of the two interaction terms differ. 

Now we test which proportion of the posteriors of the slopes from the corrected model differs from the means of the posteriors from the uncorrected model. We don't just test whether they differ, but in which direction they differ. If the correction indeed helps us to see the divergence in preferences more clearly, we expect the slope for *heu* males to be steeper and for *lin* males to be less steep in the corrected model. This will also be seen in the proportion of the difference posterior being bigger than the mean of the difference posterior without correction.
```{r}
iterations<-nrow(group_post_main_interact_corrected)/2
print(data.frame(test=c("HC (corrected) > HC (uncorrected)","TLC (corrected) < TLC (uncorrected)","HC-TLC (corrected) > HC-TLC (uncorrected)"),
                 posterior_prob=c(sum(slope_HC_corr>mean(slope_HC))/iterations,sum(slope_TLC_corr<mean(slope_TLC))/iterations,sum(difference_post_slopes_corrected>mean(difference_post_slopes))/iterations)))
```

Indeed, we do find a very slight 'improvement'. The slope for *heu* males is slightly steeper and for *lin* males slightly less steep, therefore the difference of the slopes is being than for the model on the uncorrected data. But the improvement is very weak.

As a last step, we also extract the posteriors from the model exploring different light environment classes.

Extract the posteriors for all levels of type from the categorical model, under varying light environment class at *heu* model
```{r}
group_est_light_class<-suppressWarnings(suppressMessages(emmeans(mod1.208_light_cat, ~type|light_class_HC, transform="response")))
```

We extract the posteriors.
```{r}
group_post_light_class<-extract_emm_post(group_est_light_class)
```

Split posteriors by type and illuminance
```{r}
TLC_post_light_class_1<-group_post_light_class$value[group_post_light_class$type=="TLC"&group_post_light_class$light_class_HC=="sunny"]
HC_post_light_class_1<-group_post_light_class$value[group_post_light_class$type=="HC"&group_post_light_class$light_class_HC=="sunny"]
TLC_post_light_class_2<-group_post_light_class$value[group_post_light_class$type=="TLC"&group_post_light_class$light_class_HC=="cloudy"]
HC_post_light_class_2<-group_post_light_class$value[group_post_light_class$type=="HC"&group_post_light_class$light_class_HC=="cloudy"]
TLC_post_light_class_3<-group_post_light_class$value[group_post_light_class$type=="TLC"&group_post_light_class$light_class_HC=="sunny_but_treeshade"]
HC_post_light_class_3<-group_post_light_class$value[group_post_light_class$type=="HC"&group_post_light_class$light_class_HC=="sunny_but_treeshade"]
```

Create "difference posteriors"
```{r}
difference_post_light_class_1<-HC_post_light_class_1-TLC_post_light_class_1
difference_post_light_class_2<-HC_post_light_class_2-TLC_post_light_class_2
difference_post_light_class_3<-HC_post_light_class_3-TLC_post_light_class_3
```

Now we take a look at mean and 95% CrI for *lin*, *heu* and the difference between them.
```{r}
est_light_class<-data.frame(rep(c("TLC","HC","HC-TLC"),3),rep(c("sunny","cloudy","woodland shade"),each=3),rbind(c(mean(TLC_post_light_class_1),quantile(TLC_post_light_class_1,probs=c(0.025,0.975))),c(mean(HC_post_light_class_1),quantile(HC_post_light_class_1,probs=c(0.025,0.975))),c(mean(difference_post_light_class_1),quantile(difference_post_light_class_1,probs=c(0.025,0.975))),c(mean(TLC_post_light_class_2),quantile(TLC_post_light_class_2,probs=c(0.025,0.975))),c(mean(HC_post_light_class_2),quantile(HC_post_light_class_2,probs=c(0.025,0.975))),c(mean(difference_post_light_class_2),quantile(difference_post_light_class_2,probs=c(0.025,0.975))),c(mean(TLC_post_light_class_3),quantile(TLC_post_light_class_3,probs=c(0.025,0.975))),c(mean(HC_post_light_class_3),quantile(HC_post_light_class_3,probs=c(0.025,0.975))),c(mean(difference_post_light_class_3),quantile(difference_post_light_class_3,probs=c(0.025,0.975)))))

names(est_light_class)<-c("object","light_class_heu","mean","lower","upper")
print(est_light_class)
```

There seems to be again a striking effect of sunny conditions on attraction of *heu* males to the *heu* phenotype!

#### Effect of presence/absence of red colour in backcross hybrids and its interaction with illuminance measures on visual mate preference

For the backcross-to-*lin* males, we basically follow the same pipeline as before, just that instead of `type`{.R} (species), we now use presence/absence of red colour (`redYN`{.R} = genotpye at optix region) on the male wings as fixed effect.

We set the same weak priors for genotype as we did before for `type`{.R}. 

We encountered the exact same problems when including `date`{.R} (with `date_trial`{.R} nested) and `observer`{.R} as random effects. We won't show this here, but start right away with the same type of model structure as `mod1.2`{.R} above.

Since we can track hybrid broods, we decide to include `broods`{.R} nested in `exp_line`{.R} as random effect. Remember: `broods`{.R} explains relationships at the sibling-level, while `exp_line`{.R} explains relationship at the grandchildren-level. Since the model gets more complex, we increase the `adapt_delta`{.R} parameter, which makes the MCMC algorith take "smaller steps" and therefore avoiding convergence issues.
```{r}
if(file.exists("Models/mod2.2_with_exp_line.rds")){
  mod2.2_with_exp_line<-readRDS("Models/mod2.2_with_exp_line.rds")
} else{
mod2.2_with_exp_line<-suppressMessages(brm(court_lin_heu_01~redYN*log_light_HC*log_light_TLC+(1|ID)+(1|date_trial)+(1|exp_line/broods),
               prior=c(set_prior("normal(0,3)",class="b",coef="redYN1"),
                       set_prior("normal(0,3)",class="Intercept")),
               family="bernoulli",data=pref_stat_BC,chains=5,
               iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=24,
                                  control = list(adapt_delta = 0.99)))
saveRDS(mod2.2_with_exp_line,"Models/mod2.2_with_exp_line.rds")
}
```

We can see quickly that `exp_line`{.R} is causing trouble. Our model does not converge well because we have too many group-level states with often too few observations per individual level. 

Looking at the model summary, we see that we get a similar warning as above concerning divergent transitions. This is not a good sign. We even get one remarkably bad `Rhat`{.R} and ESS measures.
```{r}
suppressWarnings(summary(mod2.2_with_exp_line)$random$exp_line)
```

... we can also see this we extract variance and correlation components (the estimation error is very high).
```{r}
print(VarCorr(mod2.2_with_exp_line))
```

Therefore, we remove `exp_line`{.R} from our model, but instead look separately at the different experimental lines later (see below). We create a new model without `exp_line`{.R}.
```{r}
if(file.exists("Models/mod2.2.rds")){
  mod2.2<-readRDS("Models/mod2.2.rds")
} else{
mod2.2<-suppressMessages(update(mod2.2_with_exp_line, formula. =  ~ . - (1|exp_line/broods) + (1|broods),refresh=0,silent = TRUE,seed=25))
saveRDS(mod2.2,"Models/mod2.2.rds")
}
```

We again reduce the dataset to non-`NA`{.R}
```{r}
pref_stat_BC_red<-pref_stat_BC[!is.na(pref_stat_BC$log_light_HC)&!is.na(pref_stat_BC$log_light_TLC),]
#For safety, we drop levels (seems to cause some problems if we don't)
pref_stat_BC_red<-droplevels(pref_stat_BC_red)
```

We build the reduced version of the model. For safety, we build it from scratch, so there is no problem with the adaptation of the precompiled model.
```{r}
if(file.exists("Models/mod2.2_red.rds")){
  mod2.2_red<-readRDS("Models/mod2.2_red.rds")
} else{
mod2.2_red<-suppressMessages(brm(court_lin_heu_01~redYN*log_light_HC*log_light_TLC+(1|ID)+(1|date_trial)+(1|broods),
               prior=c(set_prior("normal(0,3)",class="b",coef="redYN1"),
                       set_prior("normal(0,3)",class="Intercept")),
               family="bernoulli",data=pref_stat_BC_red,chains=5,
               iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=26,
                                  control = list(adapt_delta = 0.99)))
saveRDS(mod2.2_red,"Models/mod2.2_red.rds")
}
```

Now we check which fixed effects we want to use. We again try out all possible combinations of the model.

Load/create the results table
```{r}
#If exists, read in
if(file.exists("Tables/WAIC_backcross.csv")){
  IC_table<-read.csv("Tables/WAIC_backcross.csv",header=T,stringsAsFactors = F)[,1:3]
} else{
  #Make empty table
  IC_table<-data.frame(Model=character(0),
                       LOOIC=numeric(0),WAIC=numeric(0),stringsAsFactors = F)
}
```

Now run the models.
```{r}
#The null model (all fixed effects and interactions removed)
if(!"mod2.200"%in%IC_table$Model){
if(file.exists("Models/mod2.200.rds")){
  mod2.200<-readRDS("Models/mod2.200.rds")
} else{
mod2.200 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN - log_light_HC - log_light_TLC - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=27))
saveRDS(mod2.200,"Models/mod2.200.rds")
}
  loo_new<-loo(mod2.200)$estimates[3,1]
  waic_new<-waic(mod2.200)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.200",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.200)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model only including redYN as fixed
if(!"mod2.201"%in%IC_table$Model){
if(file.exists("Models/mod2.201.rds")){
  mod2.201<-readRDS("Models/mod2.201.rds")
} else{
mod2.201 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - log_light_HC - log_light_TLC - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=28))
saveRDS(mod2.201,"Models/mod2.201.rds")
}
  loo_new<-loo(mod2.201)$estimates[3,1]
  waic_new<-waic(mod2.201)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.201",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.201)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model only including log-illuminance at heu 'female'
if(!"mod2.202"%in%IC_table$Model){
if(file.exists("Models/mod2.202.rds")){
  mod2.202<-readRDS("Models/mod2.202.rds")
} else{
mod2.202 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN - log_light_TLC - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=29))
saveRDS(mod2.202,"Models/mod2.202.rds")
}
  loo_new<-loo(mod2.202)$estimates[3,1]
  waic_new<-waic(mod2.202)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.202",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.202)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model only including log-illuminance at lin 'female'
if(!"mod2.203"%in%IC_table$Model){
if(file.exists("Models/mod2.203.rds")){
  mod2.203<-readRDS("Models/mod2.203.rds")
} else{
mod2.203 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN - log_light_HC - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=30))
saveRDS(mod2.203,"Models/mod2.203.rds")
}
  loo_new<-loo(mod2.203)$estimates[3,1]
  waic_new<-waic(mod2.203)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.203",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.203)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN and log-illuminance at heu 'female'
if(!"mod2.204"%in%IC_table$Model){
if(file.exists("Models/mod2.204.rds")){
  mod2.204<-readRDS("Models/mod2.204.rds")
} else{
mod2.204 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - log_light_TLC - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=31))
saveRDS(mod2.204,"Models/mod2.204.rds")
}
  loo_new<-loo(mod2.204)$estimates[3,1]
  waic_new<-waic(mod2.204)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.204",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.204)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN and log-illuminance at lin 'female'
if(!"mod2.205"%in%IC_table$Model){
if(file.exists("Models/mod2.205.rds")){
  mod2.205<-readRDS("Models/mod2.205.rds")
} else{
mod2.205 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - log_light_HC - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=32))
saveRDS(mod2.205,"Models/mod2.205.rds")
}
  loo_new<-loo(mod2.205)$estimates[3,1]
  waic_new<-waic(mod2.205)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.205",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.205)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including log-illuminance at heu 'female' and log-illuminance at lin 'female'
if(!"mod2.206"%in%IC_table$Model){
if(file.exists("Models/mod2.206.rds")){
  mod2.206<-readRDS("Models/mod2.206.rds")
} else{
mod2.206 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=33))
saveRDS(mod2.206,"Models/mod2.206.rds")
}
  loo_new<-loo(mod2.206)$estimates[3,1]
  waic_new<-waic(mod2.206)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.206",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.206)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female' and log-illuminance at lin 'female'
if(!"mod2.207"%in%IC_table$Model){
if(file.exists("Models/mod2.207.rds")){
  mod2.207<-readRDS("Models/mod2.207.rds")
} else{
mod2.207 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN:log_light_HC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=34))
saveRDS(mod2.207,"Models/mod2.207.rds")
}
  loo_new<-loo(mod2.207)$estimates[3,1]
  waic_new<-waic(mod2.207)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.207",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.207)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female' and their interaction
if(!"mod2.208"%in%IC_table$Model){
if(file.exists("Models/mod2.208.rds")){
  mod2.208<-readRDS("Models/mod2.208.rds")
} else{
mod2.208 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - log_light_TLC - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=35))
saveRDS(mod2.208,"Models/mod2.208.rds")
}
  loo_new<-loo(mod2.208)$estimates[3,1]
  waic_new<-waic(mod2.208)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.208",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.208)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at lin 'female' and their interaction
if(!"mod2.209"%in%IC_table$Model){
if(file.exists("Models/mod2.209.rds")){
  mod2.209<-readRDS("Models/mod2.209.rds")
} else{
mod2.209 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - log_light_HC - redYN:log_light_HC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=36))
saveRDS(mod2.209,"Models/mod2.209.rds")
}
  loo_new<-loo(mod2.209)$estimates[3,1]
  waic_new<-waic(mod2.209)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.209",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.209)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including log-illuminance at heu 'female', log-illuminance at lin 'female' and their interaction
if(!"mod2.210"%in%IC_table$Model){
if(file.exists("Models/mod2.210.rds")){
  mod2.210<-readRDS("Models/mod2.210.rds")
} else{
mod2.210 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN - redYN:log_light_HC - redYN:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=37))
saveRDS(mod2.210,"Models/mod2.210.rds")
}
  loo_new<-loo(mod2.210)$estimates[3,1]
  waic_new<-waic(mod2.210)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.210",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.210)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female', log-illuminance at lin 'female' and the interaction between redYN and log-illuminance at heu 'female'
if(!"mod2.211"%in%IC_table$Model){
if(file.exists("Models/mod2.211.rds")){
  mod2.211<-readRDS("Models/mod2.211.rds")
} else{
mod2.211 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN:log_light_TLC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=38))
saveRDS(mod2.211,"Models/mod2.211.rds")
}
  loo_new<-loo(mod2.211)$estimates[3,1]
  waic_new<-waic(mod2.211)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.211",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.211)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female', log-illuminance at lin 'female' and the interaction between redYN and log-illuminance at lin 'female'
if(!"mod2.212"%in%IC_table$Model){
if(file.exists("Models/mod2.212.rds")){
  mod2.212<-readRDS("Models/mod2.212.rds")
} else{
mod2.212 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN:log_light_HC - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=39))
saveRDS(mod2.212,"Models/mod2.212.rds")
}
  loo_new<-loo(mod2.212)$estimates[3,1]
  waic_new<-waic(mod2.212)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.212",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.212)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female', log-illuminance at lin 'female' and the interaction between the two log-illuminance measures
if(!"mod2.213"%in%IC_table$Model){
if(file.exists("Models/mod2.213.rds")){
  mod2.213<-readRDS("Models/mod2.213.rds")
} else{
mod2.213 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN:log_light_HC - redYN:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=40))
saveRDS(mod2.213,"Models/mod2.213.rds")
}
  loo_new<-loo(mod2.213)$estimates[3,1]
  waic_new<-waic(mod2.213)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.213",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.213)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female', log-illuminance at lin 'female', the interaction between redYN and log-illuminance at heu 'female' and the interaction between the two log-illuminance measures
if(!"mod2.214"%in%IC_table$Model){
if(file.exists("Models/mod2.214.rds")){
  mod2.214<-readRDS("Models/mod2.214.rds")
} else{
mod2.214 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=41))
saveRDS(mod2.214,"Models/mod2.214.rds")
}
  loo_new<-loo(mod2.214)$estimates[3,1]
  waic_new<-waic(mod2.214)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.214",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.214)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female', log-illuminance at lin 'female', the interaction between redYN and log-illuminance at lin 'female' and the interaction between the two log-illuminance measures
if(!"mod2.215"%in%IC_table$Model){
if(file.exists("Models/mod2.215.rds")){
  mod2.215<-readRDS("Models/mod2.215.rds")
} else{
mod2.215 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN:log_light_HC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=42))
saveRDS(mod2.215,"Models/mod2.215.rds")
}
  loo_new<-loo(mod2.215)$estimates[3,1]
  waic_new<-waic(mod2.215)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.215",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.215)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female', log-illuminance at lin 'female', the interaction between redYN and log-illuminance at heu 'female' and the interaction between redYN and log-illuminance at lin 'female'
if(!"mod2.216"%in%IC_table$Model){
if(file.exists("Models/mod2.216.rds")){
  mod2.216<-readRDS("Models/mod2.216.rds")
} else{
mod2.216 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - log_light_HC:log_light_TLC - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=43))
saveRDS(mod2.216,"Models/mod2.216.rds")
}
  loo_new<-loo(mod2.216)$estimates[3,1]
  waic_new<-waic(mod2.216)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.216",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.216)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
#The model including redYN, log-illuminance at heu 'female', log-illuminance at lin 'female' and all two-way interactions
if(!"mod2.217"%in%IC_table$Model){
if(file.exists("Models/mod2.217.rds")){
  mod2.217<-readRDS("Models/mod2.217.rds")
} else{
mod2.217 <- suppressMessages(update(mod2.2_red, formula. =  ~ . - redYN:log_light_HC:log_light_TLC,refresh=0,silent = TRUE,seed=44))
saveRDS(mod2.217,"Models/mod2.217.rds")
}
  loo_new<-loo(mod2.217)$estimates[3,1]
  waic_new<-waic(mod2.217)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.217",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod2.217)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
```

now, we calculate WAIC and LOOIC of the full model.
```{r}
if(!"mod2.2_red"%in%IC_table$Model){
  loo_new<-loo(mod2.2_red)$estimates[3,1]
  waic_new<-waic(mod2.2_red)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod2.2_red",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
  rm(mod2.2_red)
  invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
}
```

Model weights
```{r}
ic_diffs <- IC_table$WAIC - min(IC_table$WAIC)
out <- exp(-ic_diffs / 2)
out <- as.numeric(out)
out <- out / sum(out)
```

We summarize LOOIC, WAIC and WAIC weights in a table, and additionally calculate WAIC differences between best fitting model and the other models. We then sort this table by WAIC value and view it.
```{r rows.print=19}
IC_table<-data.frame(IC_table,WAIC_Diff=ic_diffs,WAIC_weight=out)
IC_table<-IC_table[order(IC_table$WAIC),]
print(cbind(Model=IC_table[,1],round(IC_table[,-1],2)))
```

We can again see that the six models, which include the interaction term between `type`{.R} and log-illuminance at the *heu* 'female' are the six best fitting models. If we add all their model weights up, we see that these models have a high weight together:
```{r}
print(round(sum(IC_table$WAIC_weight[1:6]),2))
```

We can see that the model with the best fit is `mod2.2_red`{.R}, which includes `type`{.R}, log-illuminance at *heu* 'female', log-illuminance at *lin* 'female' and possible interaction terms. We already generated this model structure fit to the full data set above, as `mod2.2`{.R}.

We safe this table:
```{r}
write.csv(IC_table,"Tables/WAIC_backcross.csv",row.names=F,quote=F)
```

We again repeat this model selection with categorical illuminance models. We split log-illuminance at the *heu* model and at the *lin* into dark and bright, following the median measurements of the dataset. We have to add two new columns for that, putting rows into each of the two times two classes.
```{r}
pref_stat_BC$quantile_low_up_1<-as.integer(cut(pref_stat_BC$log_light_HC, quantile(pref_stat_BC$log_light_HC, probs=c(0,0.5,1),na.rm = T), include.lowest=TRUE))
pref_stat_BC$quantile_low_up_1<-paste0("q",pref_stat_BC$quantile_low_up_1)
pref_stat_BC$quantile_low_up_1[pref_stat_BC$quantile_low_up_1=="qNA"]<-NA
pref_stat_BC$quantile_low_up_2<-as.integer(cut(pref_stat_BC$log_light_TLC, quantile(pref_stat_BC$log_light_TLC, probs=c(0,0.5,1),na.rm = T), include.lowest=TRUE))
pref_stat_BC$quantile_low_up_2<-paste0("q",pref_stat_BC$quantile_low_up_2)
pref_stat_BC$quantile_low_up_2[pref_stat_BC$quantile_low_up_2=="qNA"]<-NA
```

We again run all the 19 possible nested categorical models, just as we did before for the continuous data.

The full model based on the reduced dataset (i.e. without `NA`{.R}):
```{r}
if(file.exists("Models/mod_CAT_2.2_red.rds")){
  mod_CAT_2.2_red<-readRDS("Models/mod_CAT_2.2_red.rds")
} else{
  mod_CAT_2.2_red<-suppressMessages(brm(court_lin_heu_01~redYN*quantile_low_up_1*quantile_low_up_2+(1|ID)+(1|date_trial)+(1|broods),
                                        prior=c(set_prior("normal(0,3)",class="b",coef="redYN1"),
                                                set_prior("normal(0,3)",class="Intercept")),
                                        family="bernoulli",data=pref_stat_BC_red,chains=5,
                                        iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=26,control = list(adapt_delta = 0.99)))
  saveRDS(mod_CAT_2.2_red,"Models/mod_CAT_2.2_red.rds")
}
```

First, we load/create again the table:
```{r}
#If exists, read in
if(file.exists("Tables/WAIC_backcross_CAT.csv")){
  IC_table<-read.csv("Tables/WAIC_backcross_CAT.csv",header=T,stringsAsFactors = F)[,1:3]
} else{
  #Make empty table
  IC_table<-data.frame(Model=character(0),
                       LOOIC=numeric(0),WAIC=numeric(0),stringsAsFactors = F)
}
```


And all other variations...
```{r}
#The null model (all fixed effects and interactions removed)
if(!"mod_CAT_2.200"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.200.rds")){
  mod_CAT_2.200<-readRDS("Models/mod_CAT_2.200.rds")
} else{
mod_CAT_2.200 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN - quantile_low_up_1 - quantile_low_up_2 - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=27))
saveRDS(mod_CAT_2.200,"Models/mod_CAT_2.200.rds")
}
  loo_new<-loo(mod_CAT_2.200)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.200)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.200",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.200)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model only including redYN as fixed
if(!"mod_CAT_2.201"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.201.rds")){
  mod_CAT_2.201<-readRDS("Models/mod_CAT_2.201.rds")
} else{
mod_CAT_2.201 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - quantile_low_up_1 - quantile_low_up_2 - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=28))
saveRDS(mod_CAT_2.201,"Models/mod_CAT_2.201.rds")
}
  loo_new<-loo(mod_CAT_2.201)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.201)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.201",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.201)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model only including categorical illuminance at heu 'female'
if(!"mod_CAT_2.202"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.202.rds")){
  mod_CAT_2.202<-readRDS("Models/mod_CAT_2.202.rds")
} else{
mod_CAT_2.202 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN - quantile_low_up_2 - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=29))
saveRDS(mod_CAT_2.202,"Models/mod_CAT_2.202.rds")
}
  loo_new<-loo(mod_CAT_2.202)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.202)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.202",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.202)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model only including categorical illuminance at lin 'female'
if(!"mod_CAT_2.203"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.203.rds")){
  mod_CAT_2.203<-readRDS("Models/mod_CAT_2.203.rds")
} else{
mod_CAT_2.203 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN - quantile_low_up_1 - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=30))
saveRDS(mod_CAT_2.203,"Models/mod_CAT_2.203.rds")
}
  loo_new<-loo(mod_CAT_2.203)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.203)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.203",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.203)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN and categorical illuminance at heu 'female'
if(!"mod_CAT_2.204"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.204.rds")){
  mod_CAT_2.204<-readRDS("Models/mod_CAT_2.204.rds")
} else{
mod_CAT_2.204 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - quantile_low_up_2 - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=31))
saveRDS(mod_CAT_2.204,"Models/mod_CAT_2.204.rds")
}
  loo_new<-loo(mod_CAT_2.204)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.204)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.204",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.204)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN and categorical illuminance at lin 'female'
if(!"mod_CAT_2.205"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.205.rds")){
  mod_CAT_2.205<-readRDS("Models/mod_CAT_2.205.rds")
} else{
mod_CAT_2.205 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - quantile_low_up_1 - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=32))
saveRDS(mod_CAT_2.205,"Models/mod_CAT_2.205.rds")
}
  loo_new<-loo(mod_CAT_2.205)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.205)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.205",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.205)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including categorical illuminance at heu 'female' and categorical illuminance at lin 'female'
if(!"mod_CAT_2.206"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.206.rds")){
  mod_CAT_2.206<-readRDS("Models/mod_CAT_2.206.rds")
} else{
mod_CAT_2.206 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=33))
saveRDS(mod_CAT_2.206,"Models/mod_CAT_2.206.rds")
}
  loo_new<-loo(mod_CAT_2.206)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.206)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.206",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.206)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female' and categorical illuminance at lin 'female'
if(!"mod_CAT_2.207"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.207.rds")){
  mod_CAT_2.207<-readRDS("Models/mod_CAT_2.207.rds")
} else{
mod_CAT_2.207 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=34))
saveRDS(mod_CAT_2.207,"Models/mod_CAT_2.207.rds")
}
  loo_new<-loo(mod_CAT_2.207)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.207)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.207",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.207)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female' and their interaction
if(!"mod_CAT_2.208"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.208.rds")){
  mod_CAT_2.208<-readRDS("Models/mod_CAT_2.208.rds")
} else{
mod_CAT_2.208 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - quantile_low_up_2 - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=35))
saveRDS(mod_CAT_2.208,"Models/mod_CAT_2.208.rds")
}
  loo_new<-loo(mod_CAT_2.208)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.208)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.208",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.208)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at lin 'female' and their interaction
if(!"mod_CAT_2.209"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.209.rds")){
  mod_CAT_2.209<-readRDS("Models/mod_CAT_2.209.rds")
} else{
mod_CAT_2.209 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - quantile_low_up_1 - redYN:quantile_low_up_1 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=36))
saveRDS(mod_CAT_2.209,"Models/mod_CAT_2.209.rds")
}
  loo_new<-loo(mod_CAT_2.209)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.209)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.209",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.209)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including categorical illuminance at heu 'female', categorical illuminance at lin 'female' and their interaction
if(!"mod_CAT_2.210"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.210.rds")){
  mod_CAT_2.210<-readRDS("Models/mod_CAT_2.210.rds")
} else{
mod_CAT_2.210 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=37))
saveRDS(mod_CAT_2.210,"Models/mod_CAT_2.210.rds")
}
  loo_new<-loo(mod_CAT_2.210)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.210)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.210",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.210)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and the interaction between redYN and categorical illuminance at heu 'female'
if(!"mod_CAT_2.211"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.211.rds")){
  mod_CAT_2.211<-readRDS("Models/mod_CAT_2.211.rds")
} else{
mod_CAT_2.211 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN:quantile_low_up_2 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=38))
saveRDS(mod_CAT_2.211,"Models/mod_CAT_2.211.rds")
}
  loo_new<-loo(mod_CAT_2.211)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.211)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.211",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.211)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and the interaction between redYN and categorical illuminance at lin 'female'
if(!"mod_CAT_2.212"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.212.rds")){
  mod_CAT_2.212<-readRDS("Models/mod_CAT_2.212.rds")
} else{
mod_CAT_2.212 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN:quantile_low_up_1 - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=39))
saveRDS(mod_CAT_2.212,"Models/mod_CAT_2.212.rds")
}
  loo_new<-loo(mod_CAT_2.212)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.212)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.212",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.212)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and the interaction between the two categorical illuminance measures
if(!"mod_CAT_2.213"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.213.rds")){
  mod_CAT_2.213<-readRDS("Models/mod_CAT_2.213.rds")
} else{
mod_CAT_2.213 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN:quantile_low_up_1 - redYN:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=40))
saveRDS(mod_CAT_2.213,"Models/mod_CAT_2.213.rds")
}
  loo_new<-loo(mod_CAT_2.213)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.213)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.213",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.213)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female', categorical illuminance at lin 'female', the interaction between redYN and categorical illuminance at heu 'female' and the interaction between the two categorical illuminance measures
if(!"mod_CAT_2.214"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.214.rds")){
  mod_CAT_2.214<-readRDS("Models/mod_CAT_2.214.rds")
} else{
mod_CAT_2.214 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=41))
saveRDS(mod_CAT_2.214,"Models/mod_CAT_2.214.rds")
}
  loo_new<-loo(mod_CAT_2.214)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.214)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.214",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.214)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female', categorical illuminance at lin 'female', the interaction between redYN and categorical illuminance at lin 'female' and the interaction between the two categorical illuminance measures
if(!"mod_CAT_2.215"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.215.rds")){
  mod_CAT_2.215<-readRDS("Models/mod_CAT_2.215.rds")
} else{
mod_CAT_2.215 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN:quantile_low_up_1 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=42))
saveRDS(mod_CAT_2.215,"Models/mod_CAT_2.215.rds")
}
  loo_new<-loo(mod_CAT_2.215)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.215)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.215",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.215)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female', categorical illuminance at lin 'female', the interaction between redYN and categorical illuminance at heu 'female' and the interaction between redYN and categorical illuminance at lin 'female'
if(!"mod_CAT_2.216"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.216.rds")){
  mod_CAT_2.216<-readRDS("Models/mod_CAT_2.216.rds")
} else{
mod_CAT_2.216 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - quantile_low_up_1:quantile_low_up_2 - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=43))
saveRDS(mod_CAT_2.216,"Models/mod_CAT_2.216.rds")
}
  loo_new<-loo(mod_CAT_2.216)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.216)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.216",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.216)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
#The model including redYN, categorical illuminance at heu 'female', categorical illuminance at lin 'female' and all two-way interactions
if(!"mod_CAT_2.217"%in%IC_table$Model){
if(file.exists("Models/mod_CAT_2.217.rds")){
  mod_CAT_2.217<-readRDS("Models/mod_CAT_2.217.rds")
} else{
mod_CAT_2.217 <- suppressMessages(update(mod_CAT_2.2_red, formula. =  ~ . - redYN:quantile_low_up_1:quantile_low_up_2,refresh=0,silent = TRUE,seed=44))
saveRDS(mod_CAT_2.217,"Models/mod_CAT_2.217.rds")
}
  loo_new<-loo(mod_CAT_2.217)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.217)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.217",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
rm(mod_CAT_2.217)
invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
```

now, we calculate WAIC and LOOIC of the full model.
```{r}
if(!"mod_CAT_2.2_red"%in%IC_table$Model){
  loo_new<-loo(mod_CAT_2.2_red)$estimates[3,1]
  waic_new<-waic(mod_CAT_2.2_red)$estimates[3,1]
  IC_table<-rbind(IC_table,data.frame(Model="mod_CAT_2.2_red",LOOIC=loo_new,WAIC=waic_new,stringsAsFactors = F))
  rm(mod_CAT_2.2_red)
  invisible(gc())
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
}
```

Model weights
```{r}
ic_diffs <- IC_table$WAIC - min(IC_table$WAIC)
out <- exp(-ic_diffs / 2)
out <- as.numeric(out)
out <- out / sum(out)
```

We summarize LOOIC, WAIC and WAIC weights in a table, and additionally calculate WAIC differences between best fitting model and the other models. We then sort this table by WAIC value and view it. We directly save the table.
```{r rows.print=19}
IC_table<-data.frame(IC_table,WAIC_Diff=ic_diffs,WAIC_weight=out)
IC_table<-IC_table[order(IC_table$WAIC),]
print(cbind(Model=IC_table[,1],round(IC_table[,-1],2)))
write.csv(IC_table,"Tables/WAIC_backcross_CAT.csv",row.names=F,quote=F)
```

Things are a little bit less clear than before here. What we definitely see is that the categorical model including male genotype, categorical brightness score and their interaction has by far the best fit. Two of the other models including this interaction term are high up in the ranking. However, the previous best fit (with the continuous data), i.e. the model including the three-way interaction, has quite a bad fit here, as do two other models including the interaction between genotype and brightness category. Since the best fitting categorical model (i.e. `mod_CAT_2.208`{.R}) is directly comparable to the best fitting model for the pure males, we decided to use it for the Gardner-Altman plots below. However, for all the non-Gardner-Altman plots and all other analyses here, we'll focus on the best-fitting model for the continuous data.

We run best fitting categorical model on the full dataset. For the continuous data, we already have the best-fitting model fitted to the full dataset, i.e. `mod2.2`{.R}.
```{r}
if(file.exists("Models/mod2.208_cat.rds")){
  mod2.208_cat<-readRDS("Models/mod2.208_cat.rds")
} else{
mod2.208_cat<-suppressMessages(brm(court_lin_heu_01~redYN*quantile_low_up_1+(1|ID)+(1|date_trial)+(1|broods),
                                prior=c(set_prior("normal(0,3)",class="b",coef="redYN1"),
                                        set_prior("normal(0,3)",class="Intercept")),
                                family="bernoulli",data=pref_stat_BC,chains=5,
                                iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=35,
                                control = list(adapt_delta = 0.99)))
saveRDS(mod2.208_cat,"Models/mod2.208_cat.rds")
}
```

We return back to the main model.

From here on, we repeat again almost the exact same steps as for the pure taxa, which is why they will be commented on less extensively.

Model checking. We see "hairy caterpillars" on the right!
```{r}
plot(mod2.2)
```

Posterior predictive checks:
```{r}
suppressMessages(pp_check(mod2.2))
```

Model coefficients:
```{r}
print(fixef(mod2.2)[,1])
```


Next, we want to look at model estimators (estimated marginal means) and contrasts. 

Let's look at the credible intervals for `redYN`{.R} alone.
```{r}
group_est_main_BC<-suppressWarnings(suppressMessages(emmeans(mod2.2, ~redYN, transform="response")))
```

We extract the posteriors.
```{r}
group_post_main_BC<-extract_emm_post(group_est_main_BC)
```

Split posteriors by redYN
```{r}
nred_post_main<-group_post_main_BC$value[group_post_main_BC$redYN=="N"]
red_post_main<-group_post_main_BC$value[group_post_main_BC$redYN=="Y"]
```

Create "difference posterior"
```{r}
difference_post_main_BC<-red_post_main-nred_post_main
```

Now we take a look at mean and 95% CrI for non-red backcross, red backcross and the difference between them.
```{r}
est_redYN<-data.frame(c("N","Y","Y-N"),rbind(c(mean(nred_post_main),quantile(nred_post_main,probs=c(0.025,0.975))),c(mean(red_post_main),quantile(red_post_main,probs=c(0.025,0.975))),c(mean(difference_post_main_BC),quantile(difference_post_main_BC,probs=c(0.025,0.975)))))
names(est_redYN)<-c("object","mean","lower","upper")
print(est_redYN)
```

We see an effect size of about `r round(mean(difference_post_main_BC),2)`.

Now we test how likely it is that the predictors for non-red and red backcross differ. We test three hypotheses:

1) non-red males have a smaller preference score than red males.
2) red males show a preference for their own type. 
3) non-red males show a preference for their own type.

Again, 2) and 3) don't matter very much.
```{r}
print(data.frame(test=c("Y-N > 0","Y > 0","N < 0"),posterior_prop=c(sum(difference_post_main_BC>0)/length(difference_post_main_BC),sum(red_post_main>0.5)/length(red_post_main),sum(nred_post_main<0.5)/length(nred_post_main))))
```

We can see that the posterior overlap of the two predictors is  quite small! Therefore it is quite probable that the preference of the males with and without red differ. The probability for red males to have a preference is close to 50%, meaning that there is no evidence for them having a preference for their own type. We are more certain that males without red have a preference for their own type.

Now, let's look at the **simple** slopes of the interaction terms between `redYN`{.R} and log-illuminance at the *heu* 'female'.

We use the `emtrends`{.R} function again.
```{r}
group_est_main_BC_interact<-suppressWarnings(suppressMessages(emtrends(mod2.2, ~ redYN, var="log_light_HC",transform="response")))
```

Mean and 95% equal-tailed interval.
```{r}
print(extract_emm_cri(group_est_main_BC_interact))
```

We get the posteriors for the simple slopes
```{r}
group_post_main_BC_interact<-extract_emm_post(group_est_main_BC_interact)
```

We use the same hypotheses as before. In the interaction term context, they mean again something slightly different.

1) The slope of the interaction term between *lin* and log-illuminance at *heu* 'female' is smaller than the one of the interaction term between *heu* and log-illuminance at *heu* 'female'.
2) Increase in log-illuminance around the *heu* 'female' leads to an increase in preference of *heu* males for their own type (positive slope). 
3) Increase in log-illuminance around the *heu* 'female' leads to an increase in preference of *lin* males for their own type (negative slope).
```{r}
iterations<-nrow(group_post_main_BC_interact)/2
slope_BC_Y<-group_post_main_BC_interact$value[group_post_main_BC_interact$redYN=="Y"]
slope_BC_N<-group_post_main_BC_interact$value[group_post_main_BC_interact$redYN=="N"]
print(data.frame(test=c("Y > N","Y > 0","N < 0"),
                 posterior_prob=c(sum(slope_BC_Y>slope_BC_N)/iterations,sum(slope_BC_Y>0)/iterations,
                                  sum(slope_BC_N<0)/iterations)))
```

We can see that with a high probability, the slopes of the two interaction terms differ. The posteriors almost don't overlap at all. The slope for males without red colour is with very high probability negative. The slope of males with red on the wings is positive, but the support is less strong. 

We repeat the same analyses with same null hypotheses on the interaction term between male colouration and the log-illuminance of the *lin* 'female'.

`emtrends`{.R}:
```{r}
group_est_main_BC_interact<-suppressWarnings(suppressMessages(emtrends(mod2.2, ~ redYN, var="log_light_TLC",transform="response")))
```

Mean and 95% equal-tailed interval.
```{r}
print(extract_emm_cri(group_est_main_BC_interact))
```

We get the posteriors for the simple slopes
```{r}
group_post_main_BC_interact<-extract_emm_post(group_est_main_BC_interact)
```

Hypothesis testing:
```{r}
iterations<-nrow(group_post_main_BC_interact)/2
slope_BC_Y<-group_post_main_BC_interact$value[group_post_main_BC_interact$redYN=="Y"]
slope_BC_N<-group_post_main_BC_interact$value[group_post_main_BC_interact$redYN=="N"]
print(data.frame(test=c("Y > N","Y > 0","N < 0"),
                 posterior_prob=c(sum(slope_BC_Y>slope_BC_N)/iterations,sum(slope_BC_Y>0)/iterations,
                                  sum(slope_BC_N<0)/iterations)))
```

We can see that there is not much evidence for intensity at the *lin* 'female' affecting preference of males with red wing colour (termed `Y`{.R}). Males without red on the wings though seem to get more attracted to the *heu* 'female' if the *lin* 'female' is bright. The hypothesis of a negative slope is not met and both, posterior probability and Bayes factor show how unlikely a negative slope is. This positive slope of males without red causes also that there is little posterior probability for the slope of red males being bigger (in a sense of "more positive") than the slope of non-red males (in fact, it seems to be the other way around).

We repeat a similar procedure with the categorical illuminace model, `mod2.208_cat`{.R}.

Extract the posteriors for all levels of redYN from the categorical model, under varying categorical illumination at *heu* mounted female.
```{r}
group_est_cat_BC<-suppressWarnings(suppressMessages(emmeans(mod2.208_cat, ~redYN|quantile_low_up_1, transform="response")))
```

We extract the posteriors.
```{r}
group_post_cat<-extract_emm_post(group_est_cat_BC)
```

Split posteriors by redYN and illuminance categories at the *heu* female.
```{r}
nred_post_cat_1<-group_post_cat$value[group_post_cat$redYN=="N"&group_post_cat$quantile_low_up_1=="q1"]
red_post_cat_1<-group_post_cat$value[group_post_cat$redYN=="Y"&group_post_cat$quantile_low_up_1=="q1"]
nred_post_cat_2<-group_post_cat$value[group_post_cat$redYN=="N"&group_post_cat$quantile_low_up_1=="q2"]
red_post_cat_2<-group_post_cat$value[group_post_cat$redYN=="Y"&group_post_cat$quantile_low_up_1=="q2"]
```

Create "difference posteriors"
```{r}
difference_post_BC_cat_1<-red_post_cat_1-nred_post_cat_1
difference_post_BC_cat_2<-red_post_cat_2-nred_post_cat_2
```

Now we take a look at mean and 95% CrI for non-red backcrosses, red backcrosses and the difference between them. To not have too many lines, we skip parts of the previously used code by using `extract_emm_cri`{.R} instead. 
```{r}
est_types<-extract_emm_cri(group_est_cat_BC)
names(est_types)<-c("object","light_env_heu","mean","lower","upper")
contrast_table<-unname(data.frame(rep("Y-N",2),c("q1","q2"),rbind(c(mean(difference_post_BC_cat_1),quantile(difference_post_BC_cat_1,probs=c(0.025,0.975))),c(mean(difference_post_BC_cat_2),quantile(difference_post_BC_cat_2,probs=c(0.025,0.975)))),stringsAsFactors=F))
names(contrast_table)<-c("object","light_env_heu","mean","lower","upper")
est_types<-rbind(est_types[1:2,],contrast_table[1,],est_types[3:4,],contrast_table[2,])
rownames(est_types)<-NULL
print(est_types)
```

Looks pretty similar to the continuous model! (Only the effect of illuminance at the *lin* model is lacking).

Some of these calculations will be repeated by the below code to produce the plots. 

### Figure 2

Get `emmeans`{.R} estimates for the interaction between log-illuminance around *heu* 'female' and type (species) from `mod1.208_final`{.R}. We sample at 100 values distributed across the range of illuminance values.
```{r}
#We find the range of illuminance intensities at heu mounted female
data_range<-range(mod1.208_final$data$log_light_HC)
#We produce 100 values from the range between the two extremes
val_to_check<-do.call(seq,as.list(c(data_range,dist(data_range)/99)))
#Run emmeans
pure_interaction<-extract_emm_cri(emmeans(mod1.208_final, ~type|log_light_HC, transform="response",at=list(log_light_HC=val_to_check)))
```

Create histogram of the difference posteriors in the Gardner-Altman plots. We take a BIN size of 0.005.
```{r}
post_hist_main<-hist(difference_post_main,breaks=seq(floor(200*min(difference_post_main))/200,
                                                          ceiling(200*max(difference_post_main))/200,0.005),plot=F)
post_hist_cat_1<-hist(difference_post_cat_1,breaks=seq(floor(200*min(difference_post_cat_1))/200,
                                                            ceiling(200*max(difference_post_cat_1))/200,0.005),plot=F)
post_hist_cat_2<-hist(difference_post_cat_2,breaks=seq(floor(200*min(difference_post_cat_2))/200,
                                                            ceiling(200*max(difference_post_cat_2))/200,0.005),plot=F)
```

The workflow:

* Call `other_plot_functions.R`{.R} to plot panel A
* Calling `plot_proportion_stats`{.R} to produce three nicely jittered stripcharts (panel B-D) 
```{r}
pdf("Graphs/figure2.pdf",width=9,height=6)
layout(matrix(1:4,ncol=2,byrow=T))

par(oma=c(0,0.8,0,4.2))

#Produce panel A by just calling the following function (if you want to check aesthetic
#details, check the function in other_plot_functions.R). We present illuminance values
#as on a log scale.
title_to_add<-substitute(paste("Illuminance at mounted ",italic('H. heurippa'),
                               " female [",italic('lux'),"]"))
plot_interaction(covariate="log_light_HC",bay_cov1=pure_interaction,
                 text_inner_fill="",added_title=title_to_add,
                 xvalues=c(2,5,15,50,150),par_mar1 = c(3,2.9,2,0.3))

#Add line showing cutoff for dark vs bright
abline(v=median(pref_stat_TLC_HC$log_light_HC,na.rm = T),lty="dashed")

#Calling plot_proportion_stats to produce the panel with the full data
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC,
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="type",
                                     # Fixed effect in model on heu and lin
sub1_states=c("TLC","HC"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.4,2.9,2,5),
                                     # Plot margins
                                     sub1_labels=c("H. t. linaresi","H. heurippa"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.26,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=rev(c(10,20,50,100,200)),
                                     # Legend dots
                                     legend_omi=T,
                                     # Use outer margin for legend
                                     squeeze_legend=1.3,
                                     # Tighten space vertically in legend
                                     legend_info=F,
                                     # Add no additional legend info
                                     border_space=0.49,
                                     # space to left and right side of center 
                                     # that dots can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#We add a letter to the figure for this panel
text(par("usr")[1]+(0.2/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.15/par("pin")[2])*diff(par("usr")[3:4]),
     "B",font=2,cex=1.5,
     pos=2,offset=0)

#Scale all histograms so that length of the maximum bar of all posteriors is maximally
#7/9 of the distance the axis has to the plot

max_bar<-max(c(post_hist_main$counts,post_hist_cat_1$counts,post_hist_cat_2$counts))
sc_fac<-(par("cex")*1.4*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
post_hist_main$counts<-(post_hist_main$counts/max_bar)*sc_fac
post_hist_cat_1$counts<-(post_hist_cat_1$counts/max_bar)*sc_fac
post_hist_cat_2$counts<-(post_hist_cat_2$counts/max_bar)*sc_fac

#We add the Gardner-Altman part
add_gardner_altman(TLC_post_main,HC_post_main,difference_post_main,post_hist_main)

#We add the same type of swarm plot, but this time just including data from 
#dark conditions
q_match<-ifelse(is.na(pref_stat_TLC_HC$quantile_low_up_1),F,
                pref_stat_TLC_HC$quantile_low_up_1=="q1")
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC[q_match,],
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="type",
                                     # Fixed effect in model on heu and lin
                                     sub1_states=c("TLC","HC"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.4,2.9,2,5),
                                     # Plot margins
                                     sub1_labels=c("H. t. linaresi","H. heurippa"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.26,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # Add no legend
                                     legend_omi=T,
                                     # Use outer margin for legend
                                     squeeze_legend=1.3,
                                     # Tighten space vertically in legend
                                     legend_info=F,
                                     # Add no additional legend info
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     #can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#We add a letter to the figure for this panel
text(par("usr")[1]+(0.2/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.15/par("pin")[2])*diff(par("usr")[3:4]),
     "C",font=2,cex=1.5,
     pos=2,offset=0)

#We add the Gardner-Altman part for that panel
add_gardner_altman(TLC_post_cat_1,HC_post_cat_1,difference_post_cat_1,post_hist_cat_1)


#We add the same type of swarm plot, but this time just including data from 
#bright conditions
q_match<-ifelse(is.na(pref_stat_TLC_HC$quantile_low_up_1),F,
                pref_stat_TLC_HC$quantile_low_up_1=="q2")
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC[q_match,],
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="type",
                                     # Fixed effect in model on heu and lin
                                     sub1_states=c("TLC","HC"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.4,2.9,2,5),
                                     # Plot margins
                                     sub1_labels=c("H. t. linaresi","H. heurippa"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.26,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=rev(c(5,10,20,50,100)),
                                     # Legend dots
                                     legend_omi=T,
                                     # Use outer margin for legend
                                     squeeze_legend=1.3,
                                     # Tighten space vertically in legend
                                     legend_info=F,
                                     # Add no additional legend info
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#We add a letter to the figure for this panel
text(par("usr")[1]+(0.2/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.15/par("pin")[2])*diff(par("usr")[3:4]),
     "D",font=2,cex=1.5,
     pos=2,offset=0)

#We add the Gardner-Altman part for that panel
add_gardner_altman(TLC_post_cat_2,HC_post_cat_2,difference_post_cat_2,post_hist_cat_2)
y_labl<-substitute(paste("Proportion interactions with mounted  ",
                         italic('H. heurippa')," female"))
mtext(y_labl,
      2,outer=T,line=-0.4,cex=0.8)

#Close plotting device.
invisible(dev.off())
```

We convert the pdf to png, so we have both file types at hand later.
Unfortunately, the Greek Delta sign gets lost in this process... It is there though in the pdf.
```{r}
invisible(pdf_convert("Graphs/figure2.pdf",filenames="Graphs/figure2.png",dpi=300,verbose=F))
```

Show png we just made
```{r}
fig2<-readPNG("Graphs/figure2.png")
grid.raster(fig2)
```

### Supplementary Figure 2

In this figure, we visualize our results from "manually" scoring video footage of the broad light environment classes inside our experimental cage during behavioural interactions. We first show a sketch of the broad light environments (the PNG image we load will not be provide online), then we show the measurements of the light logger at the *heu* model under these light environment classes and finally we show how male visual attraction behaviour differs in these three classes.

First we create again "difference posteriors" for Gardner-Altman plots.
```{r}
post_hist_class_1<-hist(difference_post_light_class_1,breaks=seq(floor(200*min(difference_post_light_class_1))/200,
                                                          ceiling(200*max(difference_post_light_class_1))/200,0.005),plot=F)
post_hist_class_2<-hist(difference_post_light_class_2,breaks=seq(floor(200*min(difference_post_light_class_2))/200,
                                                            ceiling(200*max(difference_post_light_class_2))/200,0.005),plot=F)
post_hist_class_3<-hist(difference_post_light_class_3,breaks=seq(floor(200*min(difference_post_light_class_3))/200,
                                                               ceiling(200*max(difference_post_light_class_3))/200,0.005),plot=F)
```

Then comes the plot.
```{r}
png("Graphs/supplementary_figure2.png",height=4000,width=4500,res=300)

#Read in PNG of sketch
envir<-readPNG("environments.png")

layout(matrix(c(1,1,1,2,2,2,3,4,5),ncol=3,byrow=T))
par(oma=c(0,4,0,0))

#Plot sketch
par(mar=c(0,0,0,0))
plot.new()
rasterImage(envir,xleft=-0.04,ybottom=-0.04,xright=1.04,ytop=1.04)

text(par("usr")[1]+(0.4/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "A",font=2,cex=3,
     pos=2,offset=0)

#Plot beeswarm of illuminance logger measurements from the three classes.
par(mar=c(2,0,2,0))
x_cats<-factor(pref_stat_TLC_HC$light_class_HC,
               levels=c("sunny","cloudy","sunny_but_treeshade"))
beeswarm(pref_stat_TLC_HC$log_light_HC~x_cats,
         cex=0.55,xaxt="n",yaxt="n",xlab="",ylab="",pch=21,xaxs="i")
#Add corrected measurements next to the woodland shade category
wood_match<-pref_stat_TLC_HC$light_class_HC=="sunny_but_treeshade"
woodland<-pref_stat_TLC_HC$log_light_HC_corrected[wood_match]
beeswarm(woodland,
         cex=0.55,xaxt="n",yaxt="n",xlab="",ylab="",
         pch=21,at=3.18,col=adjustcolor("lightblue",0.7),add=T)
#Axes and title
ax_names<-c("sunny","'open/cloudy'","cloudy","woodland shade")
axis(1,at=c(1,1.5,2,3),ax_names,lwd=0,line=0.2,cex.axis=2.5)
par(xpd=NA)
arrows(c(1.3,1.7),par("usr")[3]-0.05*diff(par("usr")[3:4]),
       c(1.16,1.84),par("usr")[3]-0.05*diff(par("usr")[3:4]),length=0.13,lwd=1.4)
par(xpd=F)
axis(2,at=log10(c(2,5,15,50,150)*1000),paste0(c(2,5,15,50,150),"k"),las=2,lwd=0,line=-0.5)
axis(2,at=log10(c(2,5,15,50,150)*1000),labels=F,tck=-0.015)
y_labl<-substitute(paste("Illuminance at mounted ",italic('H. heurippa'),
                         " female [",italic('lux'),"]"))
mtext(y_labl,2,line=2.45)

text(par("usr")[1]+(0.4/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "B",font=2,cex=3,
     pos=2,offset=0)

#We add the same type of swarm plot as before, but this time just including data from 
#the sun-exposed heu model light class
l_class<-ifelse(is.na(pref_stat_TLC_HC$light_class_HC),F,
                pref_stat_TLC_HC$light_class_HC=="sunny")
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC[l_class,],
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="type",
                                     # First fixed effect in model on heu and lin
                                     sub1_states=c("TLC","HC"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,7.4,2,8.5),
                                     # Plot margins
                                     sub1_labels=c("H. t. linaresi","H. heurippa"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.45,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # Legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

par(xpd=NA)
text(par("usr")[1]-(0.6/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "C",font=2,cex=3,
     pos=2,offset=0)
par(xpd=F)

#Scale all histograms so that length of the maximum bar of all posteriors is maximally
#7/9 of the distance the axis has to the plot
max_bar<-max(c(post_hist_class_1$counts,post_hist_class_2$counts,
               post_hist_class_3$counts))
sc_fac<-(par("cex")*1.4*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
post_hist_class_1$counts<-(post_hist_class_1$counts/max_bar)*sc_fac
post_hist_class_2$counts<-(post_hist_class_2$counts/max_bar)*sc_fac
post_hist_class_3$counts<-(post_hist_class_3$counts/max_bar)*sc_fac

#We add the Gardner-Altman part for that panel
add_gardner_altman(TLC_post_light_class_1,HC_post_light_class_1,
                   difference_post_light_class_1,post_hist_class_1)

#Add title
y_labl<-substitute(paste("Proportion interactions with mounted  ",
                         italic('H. heurippa')," female"))
mtext(y_labl,2,line=9.9)

#We add the same type of swarm plot, but this time just including data from the heu model
#under cloudy light class
l_class<-ifelse(is.na(pref_stat_TLC_HC$light_class_HC),F,
                pref_stat_TLC_HC$light_class_HC=="cloudy")
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC[l_class,],
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="type",
                                     # First fixed effect in model on heu and lin
                                     sub1_states=c("TLC","HC"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,6.9,2,9),
                                     # Plot margins
                                     sub1_labels=c("H. t. linaresi","H. heurippa"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.45,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # Legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#We add the Gardner-Altman part for that panel
add_gardner_altman(TLC_post_light_class_2,HC_post_light_class_2,
                   difference_post_light_class_2,post_hist_class_2)

#We add the same type of swarm plot, but this time just including data from the heu model
#under woodland shade light class
l_class<-ifelse(is.na(pref_stat_TLC_HC$light_class_HC),F,
                pref_stat_TLC_HC$light_class_HC=="sunny_but_treeshade")
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC[l_class,],
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="type",
                                     # First fixed effect in model on heu and lin
                                     sub1_states=c("TLC","HC"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,6.4,2,9.5),
                                     # Plot margins
                                     sub1_labels=c("H. t. linaresi","H. heurippa"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.45,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=rev(c(5,10,20,50,100)),
                                     # Legend dots
                                     squeeze_legend=0.75,
                                     # Tighten space vertically in legend
                                     legend_info=F,
                                     # Add no additional legend info
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#We add the Gardner-Altman part for that panel
add_gardner_altman(TLC_post_light_class_3,HC_post_light_class_3,
                   difference_post_light_class_3,post_hist_class_3)

#Close plotting device.
invisible(dev.off())
```

Show PNG we just made.
```{r}
suppl_fig2<-readPNG("Graphs/supplementary_figure2.png")
grid.raster(suppl_fig2)
```

### Figure 4

Now we look at how the light environment influences visual preferences in differently coloured backcross to *lin* males.

Create histogram of the difference posteriors in the following Gardner-Altman plots. We take a BIN size of 0.005.
```{r}
post_hist_BC_cat_1<-hist(difference_post_BC_cat_1,breaks=seq(floor(200*min(difference_post_BC_cat_1))/200,
                                                            ceiling(200*max(difference_post_BC_cat_1))/200,0.005),plot=F)
post_hist_BC_cat_2<-hist(difference_post_BC_cat_2,breaks=seq(floor(200*min(difference_post_BC_cat_2))/200,
                                                            ceiling(200*max(difference_post_BC_cat_2))/200,0.005),plot=F)
```

We produce the figure.
```{r}
pdf("Graphs/figure4.pdf",height=4,width=9)

layout(matrix(1:2,nrow=1))

#We reduce the cex parameter so that elements don't get too big
par(cex=2/3)

par(oma=c(0,0.9,0,4.5))

#We add the same type of swarm plot, but this time just including data from dark
#conditions at the heu model
q_match<-ifelse(is.na(pref_stat_BC$quantile_low_up_1),F,
                pref_stat_BC$quantile_low_up_1=="q1")
testout_bayes<-plot_proportion_stats(input_data=pref_stat_BC[q_match,],
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="redYN",
                                     # First fixed effect in model on heu and lin
                                     sub1_states=c("N","Y"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,2.9,2.8,5),
                                     # Plot margins
                                     sub1_labels=c("Non-Red","Red"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.26,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # Legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#We add a letter to the figure for this panel
text(par("usr")[1]+(0.2/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.15/par("pin")[2])*diff(par("usr")[3:4]),
     "A",font=2,cex=1.5,
     pos=2,offset=0)

#Scale all histograms so that length of the maximum bar of all posteriors is maximally
#7/9 of the distance the axis has to the plot
max_bar<-max(c(post_hist_BC_cat_1$counts,post_hist_BC_cat_2$counts))
sc_fac<-(par("cex")*1.4*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
post_hist_BC_cat_1$counts<-(post_hist_BC_cat_1$counts/max_bar)*sc_fac
post_hist_BC_cat_2$counts<-(post_hist_BC_cat_2$counts/max_bar)*sc_fac

#We add the Gardner-Altman part for that panel
add_gardner_altman(nred_post_cat_1,red_post_cat_1,
                   difference_post_BC_cat_1,post_hist_BC_cat_1)


#We add the same type of swarm plot, but this time just including data from bright 
#heu conditions
q_match<-ifelse(is.na(pref_stat_BC$quantile_low_up_1),F,
                pref_stat_BC$quantile_low_up_1=="q2")
testout_bayes<-plot_proportion_stats(input_data=pref_stat_BC[q_match,],
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="redYN",
                                     # First fixed effect in model on heu and lin
                                     sub1_states=c("N","Y"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,2.9,2.8,5),
                                     # Plot margins
                                     sub1_labels=c("Non-Red","Red"),
                                     # x axis labels
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.26,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=rev(c(5,10,20,50,100)),
                                     # Legend dots
                                     squeeze_legend=0.75,
                                     # Tighten space vertically in legend
                                     legend_info=F,
                                     # Add no additional legend info
                                     legend_omi=T,
                                     # Use outer plot space
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#We add a letter to the figure for this panel
text(par("usr")[1]+(0.2/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.15/par("pin")[2])*diff(par("usr")[3:4]),
     "B",font=2,cex=1.5,
     pos=2,offset=0)

#We add the Gardner-Altman part for that panel
add_gardner_altman(nred_post_cat_2,red_post_cat_2,
                   difference_post_BC_cat_2,post_hist_BC_cat_2)

y_labl<-substitute(paste("Proportion interactions with mounted  ",
                         italic('H. heurippa')," female"))
mtext(y_labl,2,outer=T,line=-0.4,cex=0.8)

#Close plotting device.
invisible(dev.off())
```

We convert the pdf to png, so we have both file types at hand later.
Unfortunately, the Greek Delta sign gets lost in this process... It is there though in the pdf.
```{r}
invisible(pdf_convert("Graphs/figure4.pdf",filenames="Graphs/figure4.png",dpi=300,verbose=F))
```

Show png we just made
```{r}
fig4<-readPNG("Graphs/figure4.png")
grid.raster(fig4)
```


### Supplementary figure 6

Now we look at backcross to *lin* hybrids without subsetting into different light categories. We look at the model estimates from `mod2.2`{.R}.

Create histogram of the difference posterior (same as for the figure above).
```{r}
post_hist_main_BC<-hist(difference_post_main_BC,breaks=seq(floor(200*min(difference_post_main_BC))/200,
                                                          ceiling(200*max(difference_post_main_BC))/200,0.005),plot=F)
```

Produce the figure.
```{r}
png("Graphs/supplementary_figure6.png",width=2000,height=1600,res=300)
#Calling plot_proportion_stats to produce the panel with the full data
y_labl<-substitute(paste("Proportion interactions with mounted  ",
                         italic('H. heurippa')," female"))
testout_bayes<-plot_proportion_stats(input_data=pref_stat_BC,
                                     # The data set
                                     sum_by_col_plot=c("ID"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub1_col="redYN",
                                     # First fixed effect in model on heu and lin
                                     sub1_states=c("N","Y"),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,3,0.3,9),
                                     # Plot margins
                                     sub1_labels=c("Non-Red","Red"),
                                     # x axis labels
                                     yaxs_label=y_labl,
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.26,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list("blue","red"),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=rev(c(10,20,50,100,200)),
                                     # Legend dots
                                     legend_omi=T,
                                     # Use outer margin for legend
                                     squeeze_legend=0.75,
                                     # Tighten space vertically in legend
                                     legend_info=F,
                                     # Add no additional legend info
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

#Scale histogram
sc_fac<-(par("cex")*1.4*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
post_hist_main_BC$counts<-(post_hist_main_BC$counts/max(post_hist_main_BC$counts))*sc_fac

#We add the Gardner-Altman part
add_gardner_altman(nred_post_main,red_post_main,
                   difference_post_main_BC,post_hist_main_BC)

#We add the estimators from figure 2B onto the right side
par(xpd=NA)
seg_fac<-(par("cex")*1.3*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
seg_fac2<-(par("cex")*1.7*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
segments(2+seg_fac,mean(TLC_post_main),2+seg_fac2,mean(TLC_post_main),
         lwd=3,col="blue",lend=3)
segments(2+seg_fac,mean(HC_post_main),2+seg_fac2,mean(HC_post_main),
         lwd=3,col="red",lend=3)
par(xpd=F)

#Close plotting device.
invisible(dev.off())
```

Show png we just made
```{r}
suppl_fig5<-readPNG("Graphs/supplementary_figure6.png")
grid.raster(suppl_fig5)
```


### Supplementary figure 5

We now want to produce an overview over different hybrid crosses, and how they are affected by illuminance at the *heu* model. Also, we want to show how preferences of individuals change, therefore we'll produce so-called "reaction norm" plots.

In order to do this, we have to restructure the posteriors we created for *lin*, *heu* and the backcross to *lin* hybrids. Additionally, we have to let a new categorical model run for F1 and backcross to *heu* hybrids.

First, create a new dataset for F1 and backcross to *heu* hybrids.
```{r}
pref_stat_other_hyb<-pref_stat[pref_stat$type%in%c("HCxTLC","TLCxHC","HCx(TLCxHC)"),]
#We unite both types of F1 crosses
pref_stat_other_hyb$type[pref_stat_other_hyb$type%in%c("HCxTLC","TLCxHC")]<-"F1"
#Make relevant columns factors
make_fact<-c("type","ID","date_trial","broods")
for(change_fact in 1:length(make_fact)){
    pref_stat_other_hyb[,make_fact[change_fact]]<-as.factor(pref_stat_other_hyb[,make_fact[change_fact]])
}
```

We create two categories for light conditions.
```{r}
pref_stat_other_hyb$quantile_low_up_1<-as.integer(cut(pref_stat_other_hyb$log_light_HC, quantile(pref_stat_other_hyb$log_light_HC, probs=c(0,0.5,1),na.rm = T), include.lowest=TRUE))
pref_stat_other_hyb$quantile_low_up_1<-paste0("q",pref_stat_other_hyb$quantile_low_up_1)
pref_stat_other_hyb$quantile_low_up_1[pref_stat_other_hyb$quantile_low_up_1=="qNA"]<-NA
```

We run a new model for these two types.
```{r}
if(file.exists("Models/mod_other_hyb_cat.rds")){
  mod_other_hyb_cat<-readRDS("Models/mod_other_hyb_cat.rds")
} else{
mod_other_hyb_cat<-suppressMessages(brm(court_lin_heu_01~type*quantile_low_up_1+(1|ID)+(1|date_trial)+(1|broods),
                                           prior=c(set_prior("normal(0,3)",class="b",coef="type1"),
                       set_prior("normal(0,3)",class="Intercept")),
                             family="bernoulli",data=pref_stat_other_hyb,chains=5,
                             iter=6000, warmup=3000,refresh=0,silent = TRUE,seed=45,control = list(adapt_delta = 0.999)))
saveRDS(mod_other_hyb_cat,"Models/mod_other_hyb_cat.rds")
}
```

Extract the posteriors for all levels of type from the categorical model, under varying categorical illumination at *heu* model
```{r}
other_hyb_est_cat<-suppressWarnings(suppressMessages(emmeans(mod_other_hyb_cat, ~type|quantile_low_up_1, transform="response")))
```

We extract the posteriors.
```{r}
other_hyb_posts_cat<-extract_emm_post(other_hyb_est_cat)
```

Split posteriors by type and illuminance
```{r}
F1_post_cat_1<-other_hyb_posts_cat$value[other_hyb_posts_cat$type=="F1"&other_hyb_posts_cat$quantile_low_up_1=="q1"]
BC_H_post_cat_1<-other_hyb_posts_cat$value[other_hyb_posts_cat$type=="HCx(TLCxHC)"&other_hyb_posts_cat$quantile_low_up_1=="q1"]
F1_post_cat_2<-other_hyb_posts_cat$value[other_hyb_posts_cat$type=="F1"&other_hyb_posts_cat$quantile_low_up_1=="q2"]
BC_H_post_cat_2<-other_hyb_posts_cat$value[other_hyb_posts_cat$type=="HCx(TLCxHC)"&other_hyb_posts_cat$quantile_low_up_1=="q2"]
```

Create "difference posteriors" (this time, we compare **within** type, **not between** types)
```{r}
difference_post_F1<-F1_post_cat_2-F1_post_cat_1
difference_post_BC_H<-BC_H_post_cat_2-BC_H_post_cat_1
```

Get the histograms of the differences
```{r}
post_hist_F1<-hist(difference_post_F1,breaks=seq(floor(200*min(difference_post_F1))/200,
                                                            ceiling(200*max(difference_post_F1))/200,0.005),plot=F)
post_hist_BC_H<-hist(difference_post_BC_H,breaks=seq(floor(200*min(difference_post_BC_H))/200,
                                                            ceiling(200*max(difference_post_BC_H))/200,0.005),plot=F)
```


Now we update the backcrosses to *lin*:

Extract the posteriors for all levels of type from the categorical model, under varying categorical illumination at *heu* model
```{r}
group_est_cat_BC_only_heu<-suppressWarnings(suppressMessages(emmeans(mod2.208_cat, ~redYN|quantile_low_up_1, transform="response")))
```

We extract the posteriors.
```{r}
group_post_cat_only_heu<-extract_emm_post(group_est_cat_BC_only_heu)
```

Split posteriors by colour pattern and illuminance
```{r}
nred_post_cat_1_only_heu<-group_post_cat_only_heu$value[group_post_cat_only_heu$redYN=="N"&group_post_cat_only_heu$quantile_low_up_1=="q1"]
nred_post_cat_2_only_heu<-group_post_cat_only_heu$value[group_post_cat_only_heu$redYN=="N"&group_post_cat_only_heu$quantile_low_up_1=="q2"]
red_post_cat_1_only_heu<-group_post_cat_only_heu$value[group_post_cat_only_heu$redYN=="Y"&group_post_cat_only_heu$quantile_low_up_1=="q1"]
red_post_cat_2_only_heu<-group_post_cat_only_heu$value[group_post_cat_only_heu$redYN=="Y"&group_post_cat_only_heu$quantile_low_up_1=="q2"]
```

Create "difference posteriors" (this time, we compare **within** type, **not between** types)
```{r}
non_red_difference_post_only_heu<-nred_post_cat_2_only_heu-nred_post_cat_1_only_heu
red_difference_post_only_heu<-red_post_cat_2_only_heu-red_post_cat_1_only_heu
```

Get the histograms of the differences
```{r}
post_hist_non_red_only_heu<-hist(non_red_difference_post_only_heu,breaks=seq(floor(200*min(non_red_difference_post_only_heu))/200,
                                                      ceiling(200*max(non_red_difference_post_only_heu))/200,0.005),plot=F)
post_hist_red_only_heu<-hist(red_difference_post_only_heu,breaks=seq(floor(200*min(red_difference_post_only_heu))/200,
                                                          ceiling(200*max(red_difference_post_only_heu))/200,0.005),plot=F)
```

Now we have to update histograms for *lin* and *heu*, such that they are comparing within type
```{r}
difference_post_within_TLC<-TLC_post_cat_2-TLC_post_cat_1
difference_post_within_HC<-HC_post_cat_2-HC_post_cat_1
```

New posteriors for differences
```{r}
post_hist_within_TLC<-hist(difference_post_within_TLC,breaks=seq(floor(200*min(difference_post_within_TLC))/200,
                                                                                  ceiling(200*max(difference_post_within_TLC))/200,0.005),plot=F)
post_hist_within_HC<-hist(difference_post_within_HC,breaks=seq(floor(200*min(difference_post_within_HC))/200,
                                                                      ceiling(200*max(difference_post_within_HC))/200,0.005),plot=F)
```

Produce the figure.
```{r}
png("Graphs/supplementary_figure5.png",width=6500,height=1600,res=300)

layout(matrix(1:6,ncol=6))

par(oma=c(0,1,0,5))

#lin

#Calling plot_proportion_stats to produce the panel with the full data
TLC_t<-pref_stat_TLC_HC$type=="TLC"
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC[TLC_t,],
                                     # The data set
                                     sum_by_col_plot=c("ID","quantile_low_up_1"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub2_col="quantile_low_up_1",
                                     # First fixed effect in model on heu and lin
                                     sub2_states=list(c("q1","q2")),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     stats_for_2sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,3,0.3,5),
                                     # Plot margins
                                     sub1_labels="H. t. linaresi",
                                     sub2_labels=list(c("poorly lit","brigthly lit")),
                                     # x axis labels
                                     label_count_col = "ID",
                                     # column by which to determine sample size
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.28,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list(c("blue","blue")),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # No legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     center_space_cat=0.15,
                                     #Empty space in center for reaction norm
                                     reaction_norm_col = "ID",
                                     #Column for reaction norm
                                     reaction_norm_weights=2,
                                     #Reaction norm lines unweighted
                                     reaction_norm_max_trans=0.5,
                                     #Transparency of reaction norm lines
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

text(par("usr")[1]+(0.3/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "A",font=2,cex=2.5,
     pos=2,offset=0)

#Scale histograms
max_counts<-max(c(post_hist_within_TLC$counts,
                  post_hist_non_red_only_heu$counts,
                  post_hist_red_only_heu$counts,
                  post_hist_F1$counts,
                  post_hist_BC_H$counts,
                  post_hist_within_HC$counts))
sc_fac<-(par("cex")*1.4*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
post_hist_within_TLC$counts<-(post_hist_within_TLC$counts/max_counts)*sc_fac
post_hist_non_red_only_heu$counts<-(post_hist_non_red_only_heu$counts/max_counts)*sc_fac
post_hist_red_only_heu$counts<-(post_hist_red_only_heu$counts/max_counts)*sc_fac
post_hist_F1$counts<-(post_hist_F1$counts/max_counts)*sc_fac
post_hist_BC_H$counts<-(post_hist_BC_H$counts/max_counts)*sc_fac
post_hist_within_HC$counts<-(post_hist_within_HC$counts/max_counts)*sc_fac

#We add the Gardner-Altman part
add_gardner_altman(TLC_post_cat_1,TLC_post_cat_2,
                   difference_post_within_TLC,post_hist_within_TLC,
                   at_pos=c(0.25,0.75),add_title=F)

#We add the estimators from figure 2B onto the right side
par(xpd=NA)
seg_fac<-(par("cex")*1.3*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
seg_fac2<-(par("cex")*1.7*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
segments(1+seg_fac,mean(TLC_post_main),1+seg_fac2,mean(TLC_post_main),
         lwd=3,col="blue",lend=3)
segments(1+seg_fac,mean(HC_post_main),1+seg_fac2,mean(HC_post_main),
         lwd=3,col="red",lend=3)
par(xpd=F)


#backcross to lin, no red

#Calling plot_proportion_stats to produce the panel with the full data
BCN_t<-pref_stat_BC$redYN=="N"
testout_bayes<-plot_proportion_stats(input_data=pref_stat_BC[BCN_t,],
                                     # The data set
                                     sum_by_col_plot=c("ID","quantile_low_up_1"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub2_col="quantile_low_up_1",
                                     # First fixed effect in model on heu and lin
                                     sub2_states=list(c("q1","q2")),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     stats_for_2sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,3,0.3,5),
                                     # Plot margins
                                     sub1_labels="backcross to H. t. linaresi (no red)",
                                     sub2_labels=list(c("poorly lit","brigthly lit")),
                                     # x axis labels
                                     label_count_col = "ID",
                                     # column by which to determine sample size
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.28,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list(c("blue","blue")),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # No legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     center_space_cat=0.15,
                                     #Empty space in center for reaction norm
                                     reaction_norm_col = "ID",
                                     #Column for reaction norm
                                     reaction_norm_weights=2,
                                     #Reaction norm lines unweighted
                                     reaction_norm_max_trans=0.5,
                                     #Transparency of reaction norm lines
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

text(par("usr")[1]+(0.3/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "B",font=2,cex=2.5,
     pos=2,offset=0)

#We add the Gardner-Altman part
add_gardner_altman(nred_post_cat_1_only_heu,nred_post_cat_2_only_heu,
                   non_red_difference_post_only_heu,post_hist_non_red_only_heu,
                   at_pos=c(0.25,0.75),add_title=F)

#We add the estimators from figure 2B onto the right side
par(xpd=NA)
seg_fac<-(par("cex")*1.3*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
seg_fac2<-(par("cex")*1.7*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
segments(1+seg_fac,mean(TLC_post_main),1+seg_fac2,mean(TLC_post_main),
         lwd=3,col="blue",lend=3)
segments(1+seg_fac,mean(HC_post_main),1+seg_fac2,mean(HC_post_main),
         lwd=3,col="red",lend=3)
par(xpd=F)


#backcross to lin, red

#Calling plot_proportion_stats to produce the panel with the full data
BCY_t<-pref_stat_BC$redYN=="Y"
testout_bayes<-plot_proportion_stats(input_data=pref_stat_BC[BCY_t,],
                                     # The data set
                                     sum_by_col_plot=c("ID","quantile_low_up_1"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub2_col="quantile_low_up_1",
                                     # First fixed effect in model on heu and lin
                                     sub2_states=list(c("q1","q2")),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     stats_for_2sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,3,0.3,5),
                                     # Plot margins
                                     sub1_labels="backcross to H. t. linaresi (red)",
                                     sub2_labels=list(c("poorly lit","brigthly lit")),
                                     # x axis labels
                                     label_count_col = "ID",
                                     # column by which to determine sample size
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.28,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list(c("red","red")),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # No legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     center_space_cat=0.15,
                                     #Empty space in center for reaction norm
                                     reaction_norm_col = "ID",
                                     #Column for reaction norm
                                     reaction_norm_weights=2,
                                     #Reaction norm lines unweighted
                                     reaction_norm_max_trans=0.5,
                                     #Transparency of reaction norm lines
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

text(par("usr")[1]+(0.3/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "C",font=2,cex=2.5,
     pos=2,offset=0)

#We add the Gardner-Altman part
add_gardner_altman(red_post_cat_1_only_heu,red_post_cat_2_only_heu,
                   red_difference_post_only_heu,post_hist_red_only_heu,
                   at_pos=c(0.25,0.75),add_title=F)

#We add the estimators from figure 2B onto the right side
par(xpd=NA)
seg_fac<-(par("cex")*1.3*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
seg_fac2<-(par("cex")*1.7*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
segments(1+seg_fac,mean(TLC_post_main),1+seg_fac2,mean(TLC_post_main),
         lwd=3,col="blue",lend=3)
segments(1+seg_fac,mean(HC_post_main),1+seg_fac2,mean(HC_post_main),
         lwd=3,col="red",lend=3)
par(xpd=F)


#F1s

#Calling plot_proportion_stats to produce the panel with the full data
F1_t<-pref_stat_other_hyb$type=="F1"
testout_bayes<-plot_proportion_stats(input_data=pref_stat_other_hyb[F1_t,],
                                     # The data set
                                     sum_by_col_plot=c("ID","quantile_low_up_1"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub2_col="quantile_low_up_1",
                                     # First fixed effect in model on heu and lin
                                     sub2_states=list(c("q1","q2")),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     stats_for_2sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,3,0.3,5),
                                     # Plot margins
                                     sub1_labels="F1 males",
                                     sub2_labels=list(c("poorly lit","brigthly lit")),
                                     # x axis labels
                                     label_count_col = "ID",
                                     # column by which to determine sample size
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.28,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list(c("red","red")),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # No legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     center_space_cat=0.15,
                                     #Empty space in center for reaction norm
                                     reaction_norm_col = "ID",
                                     #Column for reaction norm
                                     reaction_norm_weights=2,
                                     #Reaction norm lines unweighted
                                     reaction_norm_max_trans=0.5,
                                     #Transparency of reaction norm lines
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

text(par("usr")[1]+(0.3/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "D",font=2,cex=2.5,
     pos=2,offset=0)

#We add the Gardner-Altman part
add_gardner_altman(F1_post_cat_1,F1_post_cat_2,
                   difference_post_F1,post_hist_F1,
                   at_pos=c(0.25,0.75),add_title=F)

#We add the estimators from figure 2B onto the right side
par(xpd=NA)
seg_fac<-(par("cex")*1.3*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
seg_fac2<-(par("cex")*1.7*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
segments(1+seg_fac,mean(TLC_post_main),1+seg_fac2,mean(TLC_post_main),
         lwd=3,col="blue",lend=3)
segments(1+seg_fac,mean(HC_post_main),1+seg_fac2,mean(HC_post_main),
         lwd=3,col="red",lend=3)
par(xpd=F)


#Now backcross to heu

#Calling plot_proportion_stats to produce the panel with the full data
BCHC_t<-pref_stat_other_hyb$type=="HCx(TLCxHC)"
testout_bayes<-plot_proportion_stats(input_data=pref_stat_other_hyb[BCHC_t,],
                                     # The data set
                                     sum_by_col_plot=c("ID","quantile_low_up_1"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub2_col="quantile_low_up_1",
                                     # First fixed effect in model on heu and lin
                                     sub2_states=list(c("q1","q2")),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     stats_for_2sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,3,0.3,5),
                                     # Plot margins
                                     sub1_labels="backcross to H. heurippa",
                                     sub2_labels=list(c("poorly lit","brigthly lit")),
                                     # x axis labels
                                     label_count_col = "ID",
                                     # column by which to determine sample size
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.28,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list(c("red","red")),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=c(),
                                     # No legend dots
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     center_space_cat=0.15,
                                     #Empty space in center for reaction norm
                                     reaction_norm_col = "ID",
                                     #Column for reaction norm
                                     reaction_norm_weights=2,
                                     #Reaction norm lines unweighted
                                     reaction_norm_max_trans=0.5,
                                     #Transparency of reaction norm lines
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

text(par("usr")[1]+(0.3/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "E",font=2,cex=2.5,
     pos=2,offset=0)

#We add the Gardner-Altman part
add_gardner_altman(BC_H_post_cat_1,BC_H_post_cat_2,
                   difference_post_BC_H,post_hist_BC_H,
                   at_pos=c(0.25,0.75),add_title=F)

#We add the estimators from figure 2B onto the right side
par(xpd=NA)
seg_fac<-(par("cex")*1.3*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
seg_fac2<-(par("cex")*1.7*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
segments(1+seg_fac,mean(TLC_post_main),1+seg_fac2,mean(TLC_post_main),
         lwd=3,col="blue",lend=3)
segments(1+seg_fac,mean(HC_post_main),1+seg_fac2,mean(HC_post_main),
         lwd=3,col="red",lend=3)
par(xpd=F)


#heu

#Calling plot_proportion_stats to produce the panel with the full data
HC_t<-pref_stat_TLC_HC$type=="HC"
testout_bayes<-plot_proportion_stats(input_data=pref_stat_TLC_HC[HC_t,],
                                     # The data set
                                     sum_by_col_plot=c("ID","quantile_low_up_1"),
                                     # Sum by ID for plot
                                     response_col="court_lin_heu_01",
                                     # Response variable
                                     sub2_col="quantile_low_up_1",
                                     # First fixed effect in model on heu and lin
                                     sub2_states=list(c("q1","q2")),
                                     # Panels from left right
                                     stats_for_1sub=F,
                                     stats_for_2sub=F,
                                     #Aesthetics:
                                     par_mar=c(2.6,3,0.3,5),
                                     # Plot margins
                                     sub1_labels="H. heurippa",
                                     sub2_labels=list(c("poorly lit","brigthly lit")),
                                     # x axis labels
                                     label_count_col = "ID",
                                     # column by which to determine sample size
                                     yaxs_label="",
                                     # y axis title
                                     y_tck=-0.015,
                                     # Tick size on y-axis
                                     horiz_0.5=F,
                                     # No horizontal line at 0.5
                                     panel_dividers=F,
                                     # No vertical panel dividers
                                     dot_size=0.28,
                                     # Factor to multiply dot sizes with (just aesthetics)
                                     dot_colours=list(c("red","red")),
                                     # Dot colours
                                     sub_box_yn=F,
                                     # No Boxplot added
                                     numb_iterations=1000,
                                     # Number iterations for assembling the points
                                     legend_dots=rev(c(10,20,50,100,200)),
                                     # Legend dots
                                     legend_omi=T,
                                     # Use outer margin for legend
                                     squeeze_legend=0.5,
                                     # Tighten space vertically in legend
                                     legend_info=F,
                                     # Add no additional legend info
                                     border_space=0.49,
                                     # space to left and right side of center that dots
                                     # can be jittered to
                                     center_space_cat=0.15,
                                     #Empty space in center for reaction norm
                                     reaction_norm_col = "ID",
                                     #Column for reaction norm
                                     reaction_norm_weights=2,
                                     #Reaction norm lines unweighted
                                     reaction_norm_max_trans=0.5,
                                     #Transparency of reaction norm lines
                                     seedi=123,
                                     # Seed
                                     verbose=F
                                     # Do not print comments
)

text(par("usr")[1]+(0.3/par("pin")[1])*diff(par("usr")[1:2]),
     par("usr")[4]-(0.25/par("pin")[2])*diff(par("usr")[3:4]),
     "F",font=2,cex=2.5,
     pos=2,offset=0)

#We add the Gardner-Altman part
add_gardner_altman(HC_post_cat_1,HC_post_cat_2,
                   difference_post_within_HC,post_hist_within_HC,
                   at_pos=c(0.25,0.75))

#We add the estimators from figure 2B onto the right side
par(xpd=NA)
seg_fac<-(par("cex")*1.3*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
seg_fac2<-(par("cex")*1.7*par("cin")[2]/par("pin")[1])*diff(par("usr")[1:2])
segments(1+seg_fac,mean(TLC_post_main),1+seg_fac2,mean(TLC_post_main),
         lwd=3,col="blue",lend=3)
segments(1+seg_fac,mean(HC_post_main),1+seg_fac2,mean(HC_post_main),
         lwd=3,col="red",lend=3)
par(xpd=F)

y_labl<-substitute(paste("Proportion interactions with mounted  ",
                         italic('H. heurippa')," female"))
mtext(y_labl,2,outer=T,line=-0.5,cex=1)

#Close plotting device.
invisible(dev.off())
```

Show png we just made. The resolution in this Markdown is unfortunately a bit too low to see the x-axis well enough (but it's well visible in the original PNG). From left to right: *lin*, backcross to *lin* without red, backcross to *lin* with red, F1, backcross to *heu*, *heu*. Left in each panel are data from poorly lit *heu* mounted female, right are data from brightly lit *heu* mounted female.
```{r}
suppl_fig4<-readPNG("Graphs/supplementary_figure5.png")
grid.raster(suppl_fig4)
```


### Supplementary figure 3

We now look at all the interaction terms involving type or presence/absence of red colour in backcross hybrids, respectively. For this, we look at the fully saturated models, `mod1.2`{.R} and `mod2.2`{.R}.
Especially displaying a three-way interaction with two continuous variables is a difficult task! Details on the code can be found in
`other_plot_functions.R`{.R}.

First, get the two-way interaction terms between log-illuminance around 'females' and type (species) from `mod1.2`{.R} and presence/absence of red colour on backcross males from `mod2.2`{.R}.
```{r}
#As before, we also first find the range of illuminance intensities at the respective female
data_range<-range(mod1.2$data$log_light_HC)
#We produce 100 values from the range between the two extremes
val_to_check<-do.call(seq,as.list(c(data_range,dist(data_range)/99)))
#Run emmeans to get slopes for the effect of illuminance around heu 'female' from mod1.2
pure_interaction_heu<-extract_emm_cri(suppressWarnings(suppressMessages(emmeans(mod1.2, ~type|log_light_HC, transform="response",
                                                                                at=list(log_light_HC=val_to_check)))))

#Repeat for effect of illuminance around lin 'female' from mod1.2
data_range<-range(mod1.2$data$log_light_TLC)
val_to_check<-do.call(seq,as.list(c(data_range,dist(data_range)/99)))
pure_interaction_lin<-extract_emm_cri(suppressWarnings(suppressMessages(emmeans(mod1.2, ~type|log_light_TLC, transform="response",at=list(log_light_TLC=val_to_check)))))

#Repeat for effect of illuminance around heu 'female' from mod2.2
data_range<-range(mod2.2$data$log_light_HC)
val_to_check<-do.call(seq,as.list(c(data_range,dist(data_range)/99)))
BC_interaction_heu<-extract_emm_cri(suppressWarnings(suppressMessages(emmeans(mod2.2, ~redYN|log_light_HC, transform="response",at=list(log_light_HC=val_to_check)))))

#Repeat for effect of illuminance around lin 'female' from mod2.2
data_range<-range(mod2.2$data$log_light_TLC)
val_to_check<-do.call(seq,as.list(c(data_range,dist(data_range)/99)))
BC_interaction_lin<-extract_emm_cri(suppressWarnings(suppressMessages(emmeans(mod2.2, ~redYN|log_light_TLC, transform="response",at=list(log_light_TLC=val_to_check)))))
```


Now the plot.
```{r}
#Opening plotting device and setting up layout. 
png("Graphs/supplementary_figure3.png",width=1280,height=2400,res=300)
layout(matrix(c(rep(c(1,4),4),rep(c(2,5),4),3,6,rep(c(7,8),4),rep(c(9,10),4),11,11),byrow=T,ncol=2))

par(oma=c(0,3,0,4))

#x-dimension of the two-way interaction plots
custom_xlim<-range(c(pure_interaction_heu$log_light_HC,pure_interaction_lin$log_light_TLC,BC_interaction_heu$log_light_HC,BC_interaction_lin$log_light_TLC))

#Produce the interaction terms with log-illuminance at heu 'female'.
plot_interaction(covariate="log_light_HC",bay_cov1=pure_interaction_heu,yaxs_side=2,par_mar1=c(0,0.4,1.6,0.4),ylabel="",added_title_cex=0.65,add_empty=F,add_xaxs = F,text_inner=F,ylabel_outer = F,ylabel_line=2,numbers=T,add_letter="A",letter_central=T,custom_xlim=custom_xlim)

added_title1<-substitute(paste("Illuminance ",italic('H. heurippa'),"[",italic('lux'),"]"))
spaces1<-"                                                            "
ylabel1<-bquote(.(spaces1)*"Proportion interactions with mounted  "~
                          italic('H. heurippa')~" female")
plot_interaction(covariate="log_light_HC",bay_cov1=BC_interaction_heu,added_title=added_title1,yaxs_side=2,par_mar1=c(0,0.4,1.6,0.4),ylabel=ylabel1,added_title_cex=0.65,add_empty=T,add_xaxs = T,text_inner=F,ylabel_outer = F,ylabel_line=2,numbers=T,colname_subset="redYN",sub_names=c("N","Y"),add_letter="B",letter_central=T,text_inner_fill="backcross with vs without red",custom_xlim=custom_xlim)

#Add some dashed lines to separate the panels
par(xpd=NA)
  segments(par("usr")[2]+diff(par("usr")[1:2])*(par("mai")[4]/par("pin")[1]),par("usr")[3]-diff(par("usr")[3:4])*(par("mai")[1]/par("pin")[2]),-100,par("usr")[3]-diff(par("usr")[3:4])*(par("mai")[1]/par("pin")[2]),lwd=1.5,lty="dashed")
  segments(par("usr")[2]+diff(par("usr")[1:2])*(par("mai")[4]/par("pin")[1]),par("usr")[3]-diff(par("usr")[3:4])*(par("mai")[1]/par("pin")[2]),par("usr")[2]+diff(par("usr")[1:2])*(par("mai")[4]/par("pin")[1]),100,lwd=1.5,lty="dashed")
  par(xpd=F)
  
#Produce the interaction terms with log-illuminance at lin 'female'.
plot_interaction(covariate="log_light_TLC",bay_cov1=pure_interaction_lin,yaxs_side=4,par_mar1=c(0,0.4,1.6,0.4),ylabel="",added_title_cex=0.65,add_empty=F,add_xaxs = F,text_inner=F,ylabel_outer = F,ylabel_line=2,numbers=T,add_letter="C",letter_central=T,custom_xlim=custom_xlim)

plot_interaction(covariate="log_light_TLC",bay_cov1=BC_interaction_lin,added_title=substitute(paste("Illuminance ",italic('H. t. linaresi')," [",italic('lux'),"]")),yaxs_side=4,par_mar1=c(0,0.4,1.6,0.4),ylabel="",added_title_cex=0.65,add_empty=T,add_xaxs = T,text_inner=F,ylabel_outer = F,ylabel_line=2,numbers=T,colname_subset="redYN",sub_names=c("N","Y"),add_letter="D",letter_central=T,text_inner_fill="backcross with vs without red",custom_xlim=custom_xlim)

#Add some dashed lines to separate the panels
par(xpd=NA)
  segments(par("usr")[1]-diff(par("usr")[1:2])*(par("mai")[2]/par("pin")[1]),par("usr")[3]-diff(par("usr")[3:4])*(par("mai")[1]/par("pin")[2]),100,par("usr")[3]-diff(par("usr")[3:4])*(par("mai")[1]/par("pin")[2]),lwd=1.5,lty="dashed")
par(xpd=F)

  
  #Add three-way interactions. Check other_plot_functions.R for details (this is quite a complex calculation)
interact3(col_range=c(0.2,0.8))

#Close plotting device.
invisible(dev.off())
```

Show png we just made
```{r,fig.height=12}
suppl_fig2<-readPNG("Graphs/supplementary_figure3.png")
grid.raster(suppl_fig2)
```

The dotted contours are weighted by the preference for *own*heu* female type (i.e. the more red the more weight). We can see that there is a slight tendency for a three-way interaction, meaning that the effect of a bright *heu* increasing preference for the own type is stronger, if the *lin* 'female' is not bright.

### Supplementary figure 4

In this figure, we take a closer look at the raw log-illuminance data and "local preferences" in the "light space". This figure should visualize were in the "illuminance space" our data is distributed in and in which regions of this space certain preferences materialize.

We now plot the raw data and local preferences. As before, details can be found in `other_plot_functions.R`{.R}.
```{r}
#Opening plotting device and setting up layout. 
png("Graphs/supplementary_figure4.png",
    res=300,height = 2000,width=1270)
layout(matrix(1:8,byrow=T,ncol=2))
par(oma=c(1.5,4,0.05,4.3))
par(mar=c(1.5,0.5,0.05,0.7))

#Plot raw lin data with Kernel densities
light_plot(whole_dataset = pref_stat_TLC_HC,subset_TF = pref_stat_TLC_HC$type=="TLC",ncat = 6,letter="A")
mtext(substitute(italic("H. t. linaresi")),2,line=2,cex=0.65)

#Plot local preferences of lin males
light_plot_pref(whole_dataset = pref_stat_TLC_HC,subset_TF = pref_stat_TLC_HC$type=="TLC",number_bins=15,
                yat=4,transparency = F,letter="E")

#Plot raw heu data with Kernel densities
light_plot(whole_dataset = pref_stat_TLC_HC,subset_TF = pref_stat_TLC_HC$type=="HC",ncat = 6,letter="B")
mtext(substitute(italic("H. heurippa")),2,line=2,cex=0.65)

#Plot local preferences of heu males
light_plot_pref(whole_dataset = pref_stat_TLC_HC,subset_TF = pref_stat_TLC_HC$type=="HC",number_bins=15,
                yat=4,transparency = F,letter="F")

#Plot raw non-red backcross data with Kernel densities
light_plot(whole_dataset = pref_stat_BC,subset_TF = pref_stat_BC$redYN=="N",ncat = 6,letter="C")
mtext(substitute(paste("Non-red BC to ",italic("H. t. linaresi"))),2,line=2,cex=0.65)

#Plot local preferences of non-red backcross males
light_plot_pref(whole_dataset = pref_stat_BC,subset_TF = pref_stat_BC$redYN=="N",number_bins=15,
                yat=4,transparency = F,letter="G")

#Add colour scale
add_scale(xprop_start = 0.235,xprop_end = 0.355,col_range=c(0,1))

#Plot raw red backcross data with Kernel densities
light_plot(whole_dataset = pref_stat_BC,subset_TF = pref_stat_BC$redYN=="Y",ncat = 6,letter="D")
mtext(substitute(paste("Red BC to ",italic("H. t. linaresi"))),2,line=2,cex=0.65)

#Plot local preferences of red backcross males
light_plot_pref(whole_dataset = pref_stat_BC,subset_TF = pref_stat_BC$redYN=="Y",number_bins=15,
                yat=4,transparency = F,letter="H")

#Add axes titles
mtext(substitute(paste("Illuminance at mounted ",italic("H. heurippa")," female")),1,outer=T,line=0.5,cex=0.65)
mtext(substitute(paste("Illuminance at mounted ",italic(" H. t. linaresi")," female")),2,outer=T,line=3,cex=0.65)

#Close plotting device.
invisible(dev.off())
```

Show png we just made
```{r,fig.height=12}
suppl_fig3<-readPNG("Graphs/supplementary_figure4.png")
grid.raster(suppl_fig3)
```

We can see the same trends that the model found. The local preferences show how the model got "tilted" into certain directions. We have to mind though that some of these "local preferences" result from just few data points, so we have to check the raw data graphs on the left to see how "important" each local preference on the right is.


# Tetrad experiments with alive females

Recode contrasts again to old setting (which was `contr.treatment`{.R}).
```{r}
options(contrasts = c("contr.treatment", "contr.poly"))
```

Read in tetrad data.
```{r}
comb_tetrad<-read.table("Data/tetrad_data.txt",header=T)
```

The columns indicate:

* **counts**: number of experiments where the combination of conditions in the other columns was matched.
* **region_heu**: wild population from which the *heu* males and females used in the experiment originated from. *bva* = Buenavista; *lej* = Lejanias;  *sma* = Santa Maria; *mix* = mixed stock combined from genepools of all previous regions
* **female**: female species involved in mating. *lin* or *heu*
* **male**: male species involved in mating. *lin* or *heu*
* **combo**: mating pair with female_male, e.g. *lin_heu* = *lin* female mated by *heu* male
* **same_type**: *same* = conspecific mating; *diff* = heterospecific mating

## Modelling

In our model, we look at how mating count depends on mating pair.
The model is of family Poisson, but with the divisions done later actually represents something similar to a multinomial model (sensu Royle, J. Andrew, and Robert M. Dorazio. Hierarchical modeling and inference in ecology: the analysis of data from populations, metapopulations and communities. Elsevier, 2008.).

We use the `brms`{.R} package as a R interface for Stan.
```{r}
#Model
if(file.exists("Models/tetr_mod.rds")){
  tetr_mod<-readRDS("Models/tetr_mod.rds")
} else{
tetr_mod<-suppressMessages(brm(counts~combo,data=comb_tetrad,family="poisson",chains=5, iter=300000, warmup=30000, refresh=0,silent = TRUE,seed=46))
saveRDS(tetr_mod,"Models/tetr_mod.rds")
}
```

## Posteriors

We extract the posteriors:
```{r}
posteriors<-posterior_samples(tetr_mod)
```

We calculate the posteriors for the counts for each mating pair. Note that here in all the following calculations, model coefficients always have to be backtransformed (exponentially) to get understandable count data. 
```{r}
post_heu_heu<-exp(posteriors[,c("b_Intercept")])
post_heu_lin<-exp(rowSums(posteriors[,c("b_Intercept","b_comboheu_lin")]))
post_lin_heu<-exp(rowSums(posteriors[,c("b_Intercept","b_combolin_heu")]))
post_lin_lin<-exp(rowSums(posteriors[,c("b_Intercept","b_combolin_lin")]))
```


## Plot, CrIs hypothesis tests

We calculate the posterior for the proportion of each mating pair.
```{r}
counts_all<-post_heu_heu+post_heu_lin+post_lin_heu+post_lin_lin
prop_heu_heu<-post_heu_heu/counts_all
prop_heu_lin<-post_heu_lin/counts_all
prop_lin_heu<-post_lin_heu/counts_all
prop_lin_lin<-post_lin_lin/counts_all
```

We calculate the mean, 2.5% and 97.5% quantile of those posteriors. Also here we use the mean (and not the median), since all means will add up to 1, but all medians won't.
```{r}
quant_heu_heu<-c(mean=mean(prop_heu_heu),quantile(prop_heu_heu,probs=c(0.025,0.975)))[c(2,1,3)]
quant_heu_lin<-c(mean=mean(prop_heu_lin),quantile(prop_heu_lin,probs=c(0.025,0.975)))[c(2,1,3)]
quant_lin_heu<-c(mean=mean(prop_lin_heu),quantile(prop_lin_heu,probs=c(0.025,0.975)))[c(2,1,3)]
quant_lin_lin<-c(mean=mean(prop_lin_lin),quantile(prop_lin_lin,probs=c(0.025,0.975)))[c(2,1,3)]
```

For each type of males (*heu* and *lin*), we also calculate a preference score comparable to previous analyses. 
```{r}
pref_heu_males<-post_heu_heu/(post_heu_heu+post_lin_heu)
pref_lin_males<-post_heu_lin/(post_heu_lin+post_lin_lin)
```

We calculate the mean, 2.5% and 97.5% quantile of those posteriors.
```{r}
quant_pref_heu<-c(mean(pref_heu_males),quantile(pref_heu_males,probs=c(0.025,0.975)))[c(2,1,3)]
quant_pref_lin<-c(mean(pref_lin_males),quantile(pref_lin_males,probs=c(0.025,0.975)))[c(2,1,3)]
```

#### CrI

Let's look at the CrIs in a table.

First the preferences of males of the two types.
```{r}
quant_tab_pref<-data.frame(c("H. t. linaresi males","H. heurippa males"),round(c(quant_pref_lin[1],quant_pref_heu[1]),3),round(c(quant_pref_lin[2],quant_pref_heu[2]),3),round(c(quant_pref_lin[3],quant_pref_heu[3]),3))
names(quant_tab_pref)<-c("Pair","2.5%","mean","97.5%")
print(quant_tab_pref)
```

Now the proportion of each mating pair.
```{r}
quant_tab_pair<-data.frame(c("lin male + heu female","lin male + lin female","heu male + heu female","heu male + lin female"),round(c(quant_heu_lin[1],quant_lin_lin[1],quant_heu_heu[1],quant_lin_heu[1]),3),round(c(quant_heu_lin[2],quant_lin_lin[2],quant_heu_heu[2],quant_lin_heu[2]),3),round(c(quant_heu_lin[3],quant_lin_lin[3],quant_heu_heu[3],quant_lin_heu[3]),3))
names(quant_tab_pair)<-c("Type","2.5%","mean","97.5%")
print(quant_tab_pair)
```

#### Numeric predictions given mounted female data

Given our results with the mounted females, we can make some numeric predictions for the tetrad experiments. Given that we know of *heu* being more vigorous, we can use the previously measured preferences under different light environments and predict what we expect as results from the tetrad experiments.

This is the observed proportion of matings involving a *heu* male:
```{r}
print(prop_mating_heu_male<-quant_heu_heu[2]+quant_lin_heu[2])
```

Here is what we predict for the overall visual preferences we measured:
```{r}
pred_heu_lin_all<-(1-prop_mating_heu_male)*mean(TLC_post_main)
pred_lin_lin_all<-(1-prop_mating_heu_male)*(1-mean(TLC_post_main))
pred_heu_heu_all<-prop_mating_heu_male*mean(HC_post_main)
pred_lin_heu_all<-prop_mating_heu_male*(1-mean(HC_post_main))
```

For poorly lit *heu* female (from the categorical model)
```{r}
pred_heu_lin_dark<-(1-prop_mating_heu_male)*mean(TLC_post_cat_1)
pred_lin_lin_dark<-(1-prop_mating_heu_male)*(1-mean(TLC_post_cat_1))
pred_heu_heu_dark<-prop_mating_heu_male*mean(HC_post_cat_1)
pred_lin_heu_dark<-prop_mating_heu_male*(1-mean(HC_post_cat_1))
```

For brightly lit *heu* female (from the categorical model)
```{r}
pred_heu_lin_bright<-(1-prop_mating_heu_male)*mean(TLC_post_cat_2)
pred_lin_lin_bright<-(1-prop_mating_heu_male)*(1-mean(TLC_post_cat_2))
pred_heu_heu_bright<-prop_mating_heu_male*mean(HC_post_cat_2)
pred_lin_heu_bright<-prop_mating_heu_male*(1-mean(HC_post_cat_2))
```

We make a nice table with CI/CrIs of real data and of estimates. We take the estimated means from the `binom.bayes`{.R} function, which are always almost exactly the same as the given probability. When given the default prior, the posterior mean is always defined as `(x + 0.5)/(n + 1)`{.R}, where `x`{.R} is successes and `n`{.R} is trials. The result from this returns a value **very** similar to the "true" estimated proportion of successes.
```{r}
tetr_est<-rbind(paste0(quant_tab_pair$mean," [",paste0(quant_tab_pair$`2.5%`,"; ",quant_tab_pair$`97.5%`),"]"),sapply(c(pred_heu_lin_all,pred_lin_lin_all,pred_heu_heu_all,pred_lin_heu_all),function(x) c(paste0(round(binom.bayes(x*89,89,type="central")[6],3)," [",paste(round(binom.bayes(x*89,89,type="central")[7:8],3),collapse="; "),"]"))),sapply(c(pred_heu_lin_dark,pred_lin_lin_dark,pred_heu_heu_dark,pred_lin_heu_dark),function(x) c(paste0(round(binom.bayes(x*89,89,type="central")[6],3)," [",paste(round(binom.bayes(x*89,89,type="central")[7:8],3),collapse="; "),"]"))),sapply(c(pred_heu_lin_bright,pred_lin_lin_bright,pred_heu_heu_bright,pred_lin_heu_bright),function(x) c(paste0(round(binom.bayes(x*89,89,type="central")[6],3)," [",paste(round(binom.bayes(x*89,89,type="central")[7:8],3),collapse="; "),"]"))))
rownames(tetr_est)<-c("true experiment","estimate all data","estimate dark","estimate bright")
colnames(tetr_est)<-c("Heu_female+Lin_male","Lin_female+Lin_male","Heu_female+Heu_male","Lin_female+Heu_male")
tetr_est<-as.data.frame(tetr_est)
print(tetr_est)
```


#### Figure 3

We visualize these proportions in a plot (see again `other_plot_functions.R`{.R} for details).
```{r}
pdf("Graphs/figure3.pdf",width=4,height=5)
tetrad_fig(prop_heu_lin=prop_heu_lin,
        prop_lin_lin=prop_lin_lin,
        prop_heu_heu=prop_heu_heu,
        prop_lin_heu=prop_lin_heu,
        quant_heu_lin=quant_heu_lin,
        quant_lin_lin=quant_lin_lin,
        quant_heu_heu=quant_heu_heu,
        quant_lin_heu=quant_lin_heu,
        datasheet=comb_tetrad,
        estimations=matrix(as.numeric(sapply(c(pred_heu_lin_bright,pred_lin_lin_bright,pred_heu_heu_bright,pred_lin_heu_bright),function(x) binom.bayes(x*89,89,type="central")[6:8])),ncol=4))
invisible(dev.off())
```

We convert the pdf to png, so we have both file types. Unfortunately, the purple dot showing the estimator in the center of each CrI for the prediction derived from the mounted female data is not showing up after the conversion. It is there in the pdf though!
```{r}
invisible(pdf_convert("Graphs/figure3.pdf",filenames="Graphs/figure3.png",dpi=300,verbose=F))
```

Show png we just made
```{r}
fig3<-readPNG("Graphs/figure3.png")
grid.raster(fig3)
```

#### Hypothesis testing

We can now test how probable it is that males either of the two types of butterflies mate assortatively, as well as whether these two types of butterflies mate assortatively overall. We could do this simply by comparing posteriors "manually", but we can also use the handy `hypothesis()`{.R} function from `brms`{.R}, which gives us some nice additional info. 

We construct calculus strings for that. We have to add all model coefficients up with the same logic as we added all posteriors up before.
```{r}
lin_lin<-"exp(Intercept+combolin_lin)"

heu_heu<-"exp(Intercept)"

heu_lin<-"exp(Intercept+comboheu_lin)"

lin_heu<-"exp(Intercept+combolin_heu)"
```

Now we test the hypothesis that *lin* males mate assortatively (this test is explicitely looking if the "preference score" of *lin* males is below 0.5):
```{r}
print(hypothesis(tetr_mod,paste0(lin_lin,">",heu_lin)))
```

Here just two examples how we can easily calculate the posterior probability (`Post.Prob`{.R}) ourselves "manually" as well, with:
```{r}
#either
print(sum(prop_lin_lin>prop_heu_lin)/length(prop_heu_lin))
#...or
print(sum(pref_lin_males<0.5)/length(pref_lin_males))
```

We see that there is weak support for assortative mating in *lin* males. In fact, they mated slightly more often with the *heu* female. Mind though that the sample size is relatively small, because *lin* males got to mate less often than *heu* males. ~43% of the posterior distribution lies left of the 0.5 line. 

We test whether *heu* males mate assortatively (this test is explicitely looking if the "preference score" of *heu* males is above 0.5):
```{r}
print(hypothesis(tetr_mod,paste0(heu_heu,">",lin_heu)))
```

We find high support for *heu* males mating more frequently with females of their own type. ~94% of the posterior distribution of "preferences" lies right of the 0.5 line.

Now we test whether there is overall assortative mating between the two types (basically combining the two previous hypothesis tests):
```{r}
print(hypothesis(tetr_mod,paste0(heu_heu,"+",lin_lin,">",lin_heu,"+",heu_lin)))
```

There is quite high support that conspecific pairs occur more frequently than heterospecific pairs. We can visualize this hypothesis test by plotting the proportional difference between conspecific and heterospecific mating calculated as $(counts_c-counts_h)/(counts_c+counts_h)$, where *c* stands for conspecific and *h* for heterospecific. The proportion of datapoints left of the dashed line equals the posterior probability returned by the `hypothesis`{.R} function.
```{r}
layout(1)
par(xpd=F)
par(mar=c(4,0.4,0.2,0.4))
hist(((post_heu_heu+post_lin_lin)-(post_heu_lin+post_lin_heu))/((post_heu_heu+post_lin_lin)+(post_heu_lin+post_lin_heu)),
     main="",ylab="",yaxt="n",xlab="",breaks=100,col="lightgrey")
mtext("Proportional Difference between Con- and Heterospec. Mating",1,line=2.7,cex=1)
abline(v=0,lwd=3,lty="dashed")
```



---------END---------


# Session Info

This Markdown was produced as a PDF. However, we also ran it in HTML format, for which we recommend to install Pandoc as described under this link: https://github.com/rstudio/rstudio/issues/4462

For nice HTML format, we recommend the package `rmdformats`{.R} with the theme `readthedown`{.R}.

Also, we installed the libraries `xcolor`{.R} and `formatR`{.R} for nicer Markdown output (not sure if they were actually necessary in the end).


Session info:
```{r}
sessionInfo()
```
